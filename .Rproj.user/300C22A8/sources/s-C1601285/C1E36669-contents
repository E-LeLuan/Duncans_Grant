---
title: "Data Simulation"
author: "lib"
date: "12/7/2018"
output: html_document
---

```{r}
#Data Simulation Script####

# R Core Team (2018). R: A language and environment for
#statistical computing. R Foundation for Statistical
#Computing, Vienna, Austria. URL
#https://www.R-project.org/.

# These are the required package to run the analysis.####
require(rmarkdown)
#citation(rmarkdown)
#  JJ Allaire, Yihui Xie, Jonathan McPherson, Javier Luraschi, Kevin Ushey, Aron
#Atkins, Hadley Wickham, Joe Cheng and Winston Chang (2018). rmarkdown: Dynamic
#Documents for R. R package version 1.10.
#https://CRAN.R-project.org/package=rmarkdown
require(tidyverse)
#citation("tidyverse")
# Hadley Wickham (2017). tidyverse: Easily Install and Load the 'Tidyverse'. R
#package version 1.2.1. https://CRAN.R-project.org/package=tidyverse
require(lme4)
#citation("lme4")
# Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting
#Linear Mixed-Effects Models Using lme4. Journal of Statistical Software,
#67(1), 1-48. doi:10.18637/jss.v067.i01.
require(lmerTest)
#citation("lmerTest")
# Kuznetsova A, Brockhoff PB, Christensen RHB (2017). “lmerTest Package: Tests in
#Linear Mixed Effects Models.” _Journal of Statistical Software_, *82*(13), 1-26.
#doi: 10.18637/jss.v082.i13 (URL: http://doi.org/10.18637/jss.v082.i13).
require(emmeans)
#citation("emmeans")
# Russell Lenth (2018). emmeans: Estimated Marginal Means, aka Least-Squares
#Means. R package version 1.2.4. https://CRAN.R-project.org/package=emmeans
require(retimes)
#citation("retimes")
# Davide Massidda (2013). retimes: Reaction Time Analysis. R package version
#0.1-2. https://CRAN.R-project.org/package=retimes
require(gamlss)
#citation("gamlss")
# Rigby R.A. and Stasinopoulos D.M. (2005). Generalized additive models for
#location, scale and shape,(with discussion), Appl. Statist., 54, part 3, pp
#507-554.

# RT pilot data to establish the distribution ####

library(readr)
FPs <- read_csv("/Volumes/CAPT MARVEL/First Pass/FPs.csv")
View(FPs)
# Import the pilot data

FPs <- filter(FPs, R4 > 0)
# Remove missing vaues

pred_fac <- filter(FPs, Condition == 1)
pred_unfac <- filter(FPs, Condition == 2)
# Filter seperatly by condition. map a new variable onto the condition 1 and 2 that are 
#more descriptive.

# Creating the structure of our simulated data set.####
# 148 participants
# 32 items -> Eye Tracking Experimental Vignettes
# Condition has 2 levels -> Prediction Facilitated & Prediction Unfacilitated
# 4 Covariates -> WRMT-III, RAN, SRS-2, & EQ

subject <- 1:148
# Telling R our subjects run from 1-148.
item <- 1:32
# Telling R our items go from 1-32
data <- expand.grid(subject, item)
# Telling R to expand or data so that subject and item have their own columns
condition <- c(rep(c(rep("predict_fac", 74), rep("predict_unfac", 74)), times = 16), 
               rep(c(rep("predict_unfac", 74), rep("predict_fac", 74)), times = 16))
# Creating our conditions prediction facilitated and prediction unfacilitated and laying 
#them out in our data set so they are correctly mapped to subject and variable.
data <- cbind(data, condition)
# Adding the column condition to our data set.
colnames(data) <- c("subject", "item", "condition")
# Mapping names onto our columns
data <- data %>% arrange(desc(data$condition))
# Arrange data as a function of all of the values in the column condition

# Simulate the data by condition prediction facilitated only.####

mexgauss(pred_fac$R4)
# The mexgauss function will generate the parameter estimates. Here we are getting the 
#parameter estimates from this sample in just the prediction facilitated condition.

rt <- pred_fac$R4
# The pred_fac is what we renamed our prediction facilitated condtion form the pilot data FPs. 

mu <- mexgauss(pred_fac$R4)[1]
mu
# Asking R to tell us what mu is from our pilot data

sigma <- mexgauss(pred_fac$R4)[2]
sigma
# Asking R to tell us what sigma is from our pilot data

nu <- mexgauss(pred_fac$R4)[3]
nu
# Asking R to tell us what nu is from our pilot data

mu <- 471
sigma <- 254 
nu <- 536
samples <- 2368
# Here is what R has told us are the parameter estimates for the prediction 
#facilitated condition. We are now assigning those numbers and the sample size required.
#The sample size is set a 2368 as this is the number of observations we will get for the
#prediction facilitated condition (148 participants x 32 items / 2 conditions = 2368).

set.seed(1234)
# This how we create simulations that are reproducable

simulated_rt <- rexGAUS(samples, mu, sigma, nu)
# Simulate a non-normally distributed distribution as reaction time data is right skewed.

sim_fac <- simulated_rt

# Now let's do the same with the prediction unfacilitated condition.####

mexgauss(pred_unfac$R4)
rt <- pred_unfac$R4
mu <- mexgauss(pred_unfac$R4)[1]
sigma <- mexgauss(pred_unfac$R4)[2]
nu <- mexgauss(pred_unfac$R4)[3]
mu <- 540
sigma <- 302
nu <- 574
samples <- 2368
set.seed(1234)
simulated_rt <- rexGAUS(samples, mu, sigma, nu)
sim_unfac <- simulated_rt

# Let's combine our two simulated conditions together in one column now.####
simulated_rt <- c(sim_fac, sim_unfac)
## Add these in one column to the data set
data$rt <- simulated_rt

data[data$rt < 100,]$rt <- NA
# Remove values less than 100 as these are not processed and will skew the data 
#incorrectly.

data %>% group_by(condition) %>% summarise_at(vars(rt), funs(mean), na.rm=TRUE)
# Our new data frame "data" will have a rt column with both our simulated conidtions.

# Let's add the EQ data into the data set in the same way for the most part. ####

EQ_real_data <- read_csv("EQ real data.csv", 
                         col_types = cols(EQ_score = col_number()))
# Data set is real raw scores obtained from a colleague

mu1 <- mexgauss(EQ_real_data$EQ_score)[1]
sigma1 <- mexgauss(EQ_real_data$EQ_score)[2]
nu1 <- mexgauss(EQ_real_data$EQ_score)[3]
set.seed(1234)
simulated_EQ <- rexGAUS(148, mu1, sigma1, nu1)
##Simulate our data for our sample size of 148 as each participant will only have one 
#score for this measure

subject <- 1:148
dataEQ <- as.tibble(cbind(simulated_EQ, subject))
# Create a tibble to manage the simulated data

alldata <- inner_join(data, dataEQ, by = "subject")
# Here we are adding the EQ data to our data frame so we can include it in the model.

# Let's add the AQ data shall we...####

AQ <- read_csv("AQ.csv", col_types = cols(AQ_score = col_number()))
# Data set is real raw scores obtained from OSF

mu2 <- mexgauss(AQ$AQ_score)[1]
sigma2 <- mexgauss(AQ$AQ_score)[2]
nu2 <- mexgauss(AQ$AQ_score)[3]
set.seed(0000)
simulated_AQ <- rexGAUS(148, mu2, sigma2, nu2)
subject <- 1:148
dataAQ <- as.tibble(cbind(simulated_AQ, subject))
alldata <- inner_join(alldata, dataAQ, by = "subject")
# The AQ simulated data in addition to the EQ and rt data are now added. 

#Let's add the RAN...####

set.seed(1234)
RAN <- rnorm(148, mean = 24.5, sd = 4.8)
# Here we have used rnorm rather than rexGAUS as the data seems to be normally 
#distributed despite it being reaction time data.
subject <- 1:148
dataRAN <- as.tibble(cbind(RAN, subject))
alldata <- inner_join(alldata, dataRAN, by = "subject")
# The RAN simulated data in addition to the AQ, EQ, & rt data are now added. 

# Let's add the WRMT-III passage comprehension scores which are serving as a stand ####
#in for the overall reading scores as data for this was unavilable.

set.seed(1111)
WRMTIIIPC = rnorm(148, mean = 110.6, sd = 10.8)
subject <- 1:148
dataWRMTIIIPC <- as.tibble(cbind(WRMTIIIPC, subject))
alldata <- inner_join(alldata, dataWRMTIIIPC, by = "subject")
# The WRMT-III passage comprehnsion simulated data in addition to the 
#RAN, AQ, EQ, & rt data are now added. 

# Word identifiaction Secondary analysis ####

set.seed(2222)
WRMTIIIWI = rnorm(148, mean = 549, sd = 22.6)
subject <- 1:148
dataWRMTIIIWI <- as.tibble(cbind(WRMTIIIWI, subject))
alldata <- inner_join(alldata, dataWRMTIIIWI, by = "subject")
# The WRMT-III word identification simulated data in addition to the 
#WRMT-III PC, RAN, AQ, EQ, & rt data are now added.


# Let's convert these to t/z scores so they are comparable ####
# We need to scale and centre the covariates (turn them into z scores) so the effect 
#will be equivelant accross covariates.

alldata$simulated_EQ <- scale(alldata$simulated_EQ)
alldata$simulated_AQ <- scale(alldata$simulated_AQ)
alldata$RAN <- scale(alldata$RAN)
alldata$WRMTIIIPC <- scale(alldata$WRMTIIIPC)
alldata$WRMTIIIWI <- scale(alldata$WRMTIIIWI)

# Running the model with all fixed factors and covariates included. ####
model_alldata <- lmer(rt ~ condition + simulated_EQ + WRMTIIIWI + RAN + simulated_AQ +
                        WRMTIIIPC +
                        (1 + condition|subject) + (0 + simulated_EQ|condition) + 
                        (0 + RAN|condition) + (0 + WRMTIIIWI|condition) + 
                        (0 + simulated_AQ|condition) + (0 + WRMTIIIPC|condition) + 
                        (1 + condition|item), alldata, REML = TRUE)
# Here the line of code says... run linear mixed model on our fixed factor rt as
#predicted by condition and our covariates create random slopes and intercepts for each
#condition by both subject and items. Also, take into accout the random effect structure
#of condition on our covariates as we expect their influence to vary as a function of 
#our manipulation. We have forced random slopes on our covariate but not random intercepts.
#This is because we expect a change in are covariates effect as a response to our 
#condition.

summary(model_alldata)
# What we are looking for here is that the model is able to converge. This will tell us
#whether our data will be sufficiently rich to support the investigation of our fixed 
#factor and covariates. It is!

#Lets look at the correaltions and see if their are any colinearity problems. ####

cor(RAN, WRMTIIIWI, method = c("pearson", "kendall", "spearman"))
cor(RAN, simulated_AQ, method = c("pearson", "kendall", "spearman"))
cor(RAN, simulated_EQ, method = c("pearson", "kendall", "spearman"))
cor(RAN, WRMTIIIPC, method = c("pearson", "kendall", "spearman"))
cor(WRMTIIIWI, simulated_EQ,method = c("pearson", "kendall", "spearman"))
cor(WRMTIIIWI, simulated_AQ, method = c("pearson", "kendall", "spearman"))
cor(WRMTIIIWI, WRMTIIIPC, method = c("pearson", "kendall", "spearman"))
cor(simulated_AQ, simulated_EQ, method = c("pearson", "kendall", "spearman"))
# Looks like we dont have any problems here

```
