char version[] = "EYEDRY VERSION OF 7/26/11 (compiled with mingw-GCC)";
/*...................................................
copyright 1990 Charles Clifton. Users of this program are permitted
to modify and distribute it at no charge but may not sell it or
include any of its code in a commercial program.

Modification of old SEGMENT program.

Assumes data consisting of:
... cond# ... item# ... #fixations in sentence x1 y1 st1 et1 x2 y2 st2 et2 ...
optionally with question to be discarded after each trial

VERSION DESIGNED TO TAKE EXCEPTIONS FILE, IN FORMAT:
item# +-changetocond#
item# +-changetocond#
...
6/88: if changetocond == 99, item is thrown out

it does the following things:
	1. writes a file of mean values for each combination
	of subject,item, subcondition, and region (where
	subcondition refers to the first, second,...nth
	condition used for an item)
	2. writes a file of mean values for each combination
	of subject, condition, and region, averaged over items
	3. writes a file of mean values for each combination
	of item, condition, and region, averaged over subjects
	4. writes to the screen and option`y the printer the
	means over items, and the means over subjects and
	items, of the data for each condition and region

To run it, you need a control file with one line for each
item/condition combination used in the experiment,
containing the following information:

item#   cond#   #regions  start of 1st region (=0) start of 2nd region
  .... start of nth region

When the control file gets read in, the condition number for
a sentence gets stored as the start of the first region
which must always be 0 anyway.

Note, the numbers in the control .cnt file are the STARTS of each
region, counting from 0 as the start of the first word.

Note, the condition numbers indicated are those in the datafile
before adjustment from the exceptions file.

The control file can be generated by combining the program EYEDRY.TEM
and your experiment-running program, and compiling and running the
resulting program.

2/28/88: code added to allow rejection of trials where the question
was answered incorrectly
6/88: restructured to calloc data storage area
6/4/88: converted from segment to FF (later EYEDRY)
11/89: modified to accept parameters file
2/90: eyegaze, eyepoke, and second pass added
8/90: minor error corrected, throw out first pass etc when fixate on
	first character of next region
9/90: in eyegaze and eyepoke discards trials when have long fixation
		in critical region
9/90: cumulative position added; start of critical region and then
		fixation position every "cum_grain" (specifiable) msec for specifiable samples
10/93: add deviation from regression analysis to first pass (and
	eventually total time and eyegaze

8/6/95: change accumulation of ms/char values to round rather than truncate

9/2/95: don't write data lines for items discarded in exceptions file

12/26/97: modify way of handling skipped lines; if "double_space" is set
to TRUE, assumes that analysis region lengths should be reduced by the number
of lines skipped. 

12/26/97: correct bug in computation of wrap-around lines when computing
reading speed as a function of region length; correct but in discarding
last region in spillover analysis

1/5/98 Marie Egan: add dev from regressions for second pass and misc. comments

6/98 maximum control and data line length increased to 4000; error corrected
in ireg (regressions in) routine so that now fixations that are outside
the passage are not counted as a legal launch site for a regression
into the region being examined.

6/98 Add option to examine only selected range of sequence of trials eg
first half

6/98 Add totalgaze option -- total gaze is sum of all fixation time in
region that was expanded exactly as it would be for eyegaze

7/98 Corrected bug that gave wrong number of items and wrong means in
.itm file for FP, TT, and GP when the user requested that zeros be 
counted in the mean durations.

9/98 Expanded spillover function to report saccade lengths and give
other selection options.

1/99 Added options to permit contingency on prior fixtion plus other
options listed below with **

**Newly implemented

1 = first fixation
	option: raw or ms/ch
	option: conditionalize on presence or absence of regression from a specified region
	**option: conditionalize on there being exactly one fixation in region
	**option: conditionalize on there being more than one fixations in region
	**option: second of two contiguous fixations in region
	**option: conditionalize on prior fixation being between i and j characters
		before beginning of region
	**option: report fixation immediately before entering region
	option: conditionalize on presence or absence of fixation in a specified region
2 = first pass time
	option: keep vs. discard trials with no appropriate fixations
	option: raw, ms/ch, deviation times
	option: conditionalize on presence or absence of regression from a specified region
	**option: conditionalize on prior fixation being between i and j characters
		before beginning of region
	option: conditionalize on presence or absence of fixation in a specified region
3 = total time
	option: keep vs. discard trials with no appropriate fixations
	option: raw, ms/ch, deviation times
	option: conditionalize on presence or absence of regression from a specified region
	**option: conditionalize on prior fixation being between i and j characters
		before beginning of region
	option: conditionalize on presence or absence of fixation in a specified region
4 = first pass regressions out (Percentage of trials where one or more
	legal first pass fixations in region were followed by a legal
	fixation to earlier point in the sentence.)
5 = regressions in (Percentage of trials where one or more legal fixations
	in region were preceded by legal fixation in a later region of the sentence.");
6 = probability of a first-pass fixation
	**option: probability of there being exactly one fixation
	**option: conditionalize on prior fixation being between i and j characters
		before beginning of region; reports pr(fix|prior fix OK) but does not
		count trials where the "prior fix" was the last fixation in the sentence
		i.e. it gives the p(fix|fix or skip)
	**option: duration of fixation just before or just after skipping region
		or landing in region
7 = number of fixations
	1 = count fixations prior to leaving region
	2 = count all fixations in region
8 = second pass times
	option: raw, ms/ch, deviation times
	1 = include only time in region after going past it
	2 = include all re-reading time after leaving region, left or right
	3 = include only time in region after leaving it to left, before going past
	4 = include only re-reading time in region after entering second specified region (Tim Slattery)
9 = eyepoke 
	option: raw or ms/ch
	1 = fixation durations
	2 = all saccade lengths
	3 = nonregressive saccades, before first regression
	4 = probability of a forward saccade
10 = eyegaze
	option: raw or ms/ch
11 = landing position
	option 1: position of first fixation in a region
	**option 2: position of the second fixation in a region
	**option 3: launch site (position of previous saccade, charc back from start of region)
12 = position as function of time
	Report fixation positions relative to
		0 = start of region
		1 = first fixation in region
	Cumulate or don't cumulate position (cumulate = no going back; Scheepers)
	Sample size in msec 10 or 20 or whatever
13 = time from entering region to first going PAST it
	option: keep vs. discard trials with no appropriate fixations
	option: raw or ms/ch
	1 = All from first entering region to first going past
	2 = Time spent in region from first entering to first going past
	3 = Time spent outside of region after entering to first going past
14 = first fixation or saccade after LEAVING region (spillover)
	option: eliminate the last fixation on a sentence
	option: record fixation duration or saccade length of the first saccade
		out of each region
	option: permit only forward-going saccades or allow regressions as well
	option: raw or ms/ch
15 = saccade matrix (from region to region)
	1 = all saccades
	2 = only saccades not following regression (first pass saccades)
16 = total gaze
	option: raw or ms/ch
17 = landing site matrix (word length by position) for Jane Ashby
plus launch site vector (letters before start of word, for the
same person.
18 = inhibition of return analysis (report location of regressions and
	the following forward saccades together with duration of preceding
	fixations)
19 = vector of entering and leaving (for readaloud experiments)
20 = lengths of regions

2/15/99: MAJOR CHANGE: changed time functions (first fix, first pass, 
total time, sec pass, gaze duration, totalgaze) so that if a fixation
over the longtime limit would be included for a region on a trial,
that region is discarded from the analysis. Previously, just the overlong
fixation was discarded, effectively replaced by zero. Extra-short fixations
are still simply ignored. Long fixations are still included in the
go-past measure, and are still counted in computing regression probabilities.
In the screening measures (prev fix in specified range) and in launch
position and landing position measures, regions with extra-long fixations
are also discarded, and they are discarded when computing the regression
coefficients.

2/16/99: Corrected reports of long and short fixations; previously counted
them repeatedly, now only count the number that were actually involved
in the measure being calculated (longs skipped or trigger region/trial
elimination, shorts skipped)

3/15/99: Corrected old error that prevented item files from being written
correctly in partly between-item design.

3/21/99 modified output procedures to create systat files

3/25/99: bug fixes (get scope right on subject file loop, get item index
right on item file loop)

3/25/99: fix ff() function so that trials on which there is a regression
out of the region between the first and second fixation are eliminated
in second fix analysis and in first of multiple fixations analysis

3/25/99: add option to analyze only the first N trials in a condition

5/10/99: Enrique Meseguer discovered a stupid bug; running a non-time-
based analysis (reg in or out, #fix) immediately after running a time-
based analysis conditionalized upon regressions, the non-time-based
analysis also conditionalized upon regressions. Fixed by resetting
cond_reg to 0 before each analysis.

5/26/99: added item file output for saccade matrix analysis

8/24/00: for Jane at Keith's behest, add analysis 17, distribution of 
landing and launch positions. Items files not done yet.

5/27/01: Add conditionalization on previous fixation position to
p_init_fix. Reports pr(fix | position) if conditionalization is chosen.

5/27/01: Add upper time cutoffs to first pass and total time (discard the
region on trials where fp or total time is above the cutoff).

6/27/01: Add analysis 18, for inhibition of return checking (gives 
info about the first regressive saccade made in a sentence plus the
next forward saccade)

6/27/01: Add cumulative version of analysis 12, position as a function
of time, following Scheepers, Hemforth, Konieczny, and van Gompel,
"Monotonicity in head-final sentence processing: Top-down prediction
of verb valency" (and correct several minor errors in old function)

7/14/01: Add option to probability of initial fixation (analysis 6) that
provides the duration of the last fixation prior to a skip or the first
fixation after a skip, or the comparable values prior to or after the initial
landing in the region.

11/14/01: made change in definition of go-past 3, so that it only counted
fixations strictly before start_region, not fixations on or before
start_region

2/6/02: added variant of first fixation function when poke_anal
== 5 (actually done some time earlier); report the fixation immediately
before entering the target region (from the left, first time). 
You may specify a launch position range; it only reports 
fixations in this range

5/16/02: added report of individual subject and overall subjects proportions
of fixations that were eliminated for being too long or too short - only 
for total time analysis

5/25/02: add printout of means where each individual response is equally
weighted to existing printout of means of subject means
				: add option to conditionalize on position of previous fixation
to landing position analysis

8/6/02: revise IOR (analysis 18) rules

10/8/02: eliminate trials with longtimes from go-past (as was
done for first pass and for second pass; add option to ignore
0 trials in second pass time

5/21/03: add option to spillover to permit getting spillover after
just single fixation in critical region

6/7/04: bug fix in p_init_fix (gave wrong fixations for option5, 
last fixation before entering region)

9/20/04: option 19 added for readaloud experiments; gives a vector of
when each region was first entered, and then first left, referenced
to start of trial (0s in both when never entered)

9/21/04: minor bug fix, so that in eliminating bad initial fixations,
it only eliminates fixation that occur before the first character. It
no longer requires the initial fixations to be in the region being analyzed.

10/11/04: put filter > shorttime && <= longtime on option 5, first fixation

10/21/04: make fp) and tt) like ff) so that they pay attention to the very
first fixation in a sentence in checking to see whether the launch region
constraint was met

7/27/06: add option 4 to second pass, to record time spent reading target
region after having entered a second trigger region (Tim Slattery)

5/20/07: fix bug in analysis 12, position as a function of time (it was writing
outside the allocated arrays at the end of a trial, and wasn't dealing
properly with cumulated positions)

11/10/08: Adrian noticed that, when eye lands in region N, then goes back to 
region N-1, then re-lands in region N, the first fixation in region N gets
counted as first fixation but NOT as single fix. He thinks it should. I don't.
OK, there should be one more option: regression-contingent/single fix.

5/28/09: minor bug fix in reporting of spillover options

7/6/09: changed format of .ixs output to work better with R input; still
planning to get a single file out in Windows eyedry that contains all
the analyses, but memory limitations make it hard in DOS. Note, line should
end with a , for missing data when there were no observations.

7/12/09: add option to first fixation analysis to keep or reject trials
based on the presence of a fixation in some specified region (not necessarily
the one being analyzed)

12/8/09: bug fix to second pass: if eliminate zero is set to FALSE, the count
of second pass fixations in a region was 1 more than it really should have
been. This systematically made 2nd pass times too small if the "average" 
option was taken - which it never should be anyway....

1/27/10: add output of sequence number to items by subject file (for order
analysis in R)

11/12/10: replace lines in sec_pass setting NV to 1 when not throwing away
zeros; affects average second pass fix duration calculation AND .ixs sec pass output

11/13/10: add option to have all conditions, all items, output in .ixs file; have
0's output in .ixs file when throwaway_zero is false (0). It would be nice to 
put all output measures on a single line for R analysis, but memory limits do
not permit

1/16/11: add analysis 20, output file of region lengths

1/16/11: add option for wide output for .ixs and region length files (i.e., put
all regions for a trial on one line rather than on separate lines - for Adrian)


7/8/11: 
from 6/4/04: Patrick Sturt; modified code to compile under gcc:
(1) Changed all occurrences of getch() to getchar().
(2) Removed references to "date" structure
(3) Added several missing "int"s in function prototypes and definitions
(4) Changed occurrences of "long int" and "short int" to "long" or "short".
(5) Re-named function "round()" to "myround()", because of conflict with math library 
(6) Removed comparison of pointer to integer (see comment at l.1752)
(7) removed reference to DOS libararies (e.g. dos.h).

N.B. Has to be linked to math library (gcc needs switch "-lm")

To compile in in gcc under unix:
gcc geyedry.c -o geyedry -lm

To compile as a stand-alone windows application under Cygwin:
gcc -mno-cygwin -static geyedry.c -o geyedry -lm

To compile as a stand-alone windows application under mingw:
navigate to mingw directory (e.g. B:\Mingw_base)
bin\i686-w64-mingw32-gcc.exe gweyedry.c -o gweyedry -lm
(or use eyedry name)

7/27/11: change oreg and ireg .ixs output from 100 to 1 for occurrence


......................................................*/


#include "stdio.h"
#include "stdlib.h"
#include "math.h"
// #include "alloc.h"
// #include "dos.h"
#include "string.h"
// #include "ctype.h"
// #include "conio.h"

int fpcutoff;
int ttcutoff;
#define EQ ==
#define MAXLINE 250
#define MAXLINEX 4000
#define TRUE 1
#define FALSE 0
#define ERR NULL                        /* from CPM86 */
void movenextnumber();
void movebacknumber();
char buff[MAXLINEX];
char qbuff[MAXLINEX];
FILE *dbuff,*Subfile,*Senfile,*Allfile;
FILE *SysSubfile,*SysSenfile;
FILE *printer;
FILE *control;
FILE *conbuff;
char file[MAXLINE], cfile[MAXLINE];
char *tbuff;
int total_samples;
int cum_positions = 100;		/* make it specifiable */
int total_samples_plus_start;
int first_seq,last_seq,curr_seq;			/* first and last trials in sequence to examine */
int max_in_cond;			/* max number of trials in a condition */
int ti1,ti2,ti3;                        /* temporary indices into arrays */
int *C; /* control info; indices are sentence#-1,
	item-cond #, and region#-1; values are  region-starts */
int *NR;        /* number of regions in each item/cond combo */
int *V; /* individual subject values */
int *NV;        /* corresponding counts */
int *CUMV; /*cumulative values, cumulated over subjects */
int *	CUMNV;
int *CONDV;                /* indiv S condition values */
int *CONDNV;
int *CUMCV;
int *CUMCNV;
int *CUMCVT;
int *CUMCNVT;
int *ITEMCOND;  /* list of actual conditions for each item */
int *ITEMSEQ;	/* list of sequence numbers for each item */
int *TCUMPOS;   /* temporary */
int *CUMPOS;    /* matrix of positions in 10 msec slices;       changes for each subject */
int *COUNT_CUMPOS;
float *TOTAL_CUMPOS;    /* total values */
int *COUNT_TOTAL_CUMPOS;
int *CUM_MATRIX,*S_MATRIX,*I_MATRIX;      /* matrix of saccades */
int debug;
int mspc;               /* raw time or msecmspc per character or dev reg*/
FILE *datalst,*except;
int vexcept[200];               /* 200 items max */
int exceptflag;
int avg;     /* average or cumulate multiple phrases */                                   /* average or cumulate multiple phrases */
int width,yoffset,max_y;
int anal;
int gazeanal;   /* set if analysis like gaze or poke */
int chatter,print_on;
int nsub;
int which_reg;
int got_fix;            /* got a fixation in the critical region? */
int move_limit;
int keep_to_right;      /* wanna keep fixations even when don't get any in expanded region? */
int throwaway_zero;     /* discard trials with no fixations in region, or not? */
										/*  1 = TRUE, 0 = FALSE, 2 = IRRELEVANT */
int ixsopt;
int longcount,shortcount,total_fixation_count;
float sum_prop_long=0;
float sum_prop_short=0;
int *longs;
int *shorts;
int cond_reg;
int which_cond_reg;
int which_matrix;
int first_region_for_regression;
int temp_fixation;
int maxregressions;
double alpha,beta;
char SenfileName[20],AllfileName[20],SubfileName[20],SysSenfileName[20],SysSubfileName[20];
int number_in_cond[100];		/* implicit max 100 conds */
int cond_fix;
int which_cond_fix;
int wide;			/* output of ixs, lengths */

/* declarations of function prototypes */
int ff(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int region_length,int poke_anal,int StartPrevFix,int EndPrevFix);
int tt(int fixation,int temppos,int temptime,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int region_length,int StartPrevFix,int EndPrevFix,int endsen);
int oreg(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns);
int ireg(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns);
int sec_pass(int fixation,int temppos,int temptime,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int *past_region,int *in_region,int poke_anal,int region_length,int endsen,int start_trigger_region, int end_trigger_region);
int cumulate_position(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int ns,int nitot,int icond,int nscmax,int gtemps,int tempy,int cum_grain,int poke_anal);
int fixes(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int nitot,int nscmax,int icond,int poke_anal,int ik,int region_length);
int gd_fixes(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int nitot,int nscmax,int icond,int ik,int region_length);
int total_fixes(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int nitot,int nscmax,int icond,int ik,int region_length);
int following_fixes(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int nitot,int nscmax,int icond,int poke_anal,int region_length);
int inhreturn(int ns,int fixation,int temppos,int temptime,int endsen,int shorttime,int longtime,int cptrptr,int sprtptr,int nitem,int ncmin,int nscmax,int nregion,int ncond,int nitot);
int sortsubject(int i,int nimin,int nimax,int ncmin,int ncmax,int nscmax,int qskip,int cpos,int ipos,int npos,int dpos,int longtime,int shorttime,int lookahead,int minq,int maxq,int qcpos,int qresppos,int nitot,int poke_anal,int cum_grain,int nregmax,int nctot,int around_end,int double_space,int StartPrevFix,int EndPrevFix,int trigger_region, int trigger_adjustment);
int region_vector(int fixation,int temppos,int temps,int tempe,int temptime,int endsen,int start_region,int end_region,int shorttime,int cptrptr,int sptrptr,int region,int ns,int ik,int* GotFix,int FP_only);
void pos_collapsecond(int relcond,int zerocond,int nimin,int nimax,int nscmax,int nitot,int nctot);
void write_position_stuff(int ncmin,int ncmax,int nctot);
void summarize(int nimin,int nimax,int nscmax,int nregmax,int ncmin,int ncmax,int nitot,int nctot,int poke_anal,int anal,int around_end);
void cleararrays(int nitot,int nctot,int nscmax,int nregmax,int subjectnumber);
void movenextnumber(void);
void movebacknumber(void);
int readnext(int control);
int spacebuff(char *bptr,int val);
int myround(int total,int count);
char *tgets(char *buff,FILE *stream);
int no_fixes(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int poke_anal);
int p_init_fix(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int poke_anal,int StartPrevFix,int EndPrevFix,int nregion);
int go_past(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int poke_anal,int region_length);
int next_fix(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int nitot,int nscmax,int icond,int ik,int poke_anal,int region_length);
int fill_matrix(int fixation,int temppos,int temptime,int shorttime,int longtime,int cptrptr,int sptrptr,int nregion,int nregmax,int ncmin,int nctot,int nitot,int nscmax,int ns,int icond,int around_end);
int land_pos(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int poke_anal,int StartPrevFix,int EndPrevFix);
void collapsecond(int ic,int cond,int nimin,int nimax,int nscmax,int nregmax,int nitot,int nctot);
void oops(char *string);
int getcontrol(int nimin,int nitot,int ncmin,int nctot,int nregmax,int nscmax);
void openfail(char *filestr);
void write_matrix(int ncmin,int ncmax,int nctot,int nregmax);
int check_reg(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int region,int ns);
int check_fix(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int region,int ns);
int correct(int *debug,int *qskip,int *lookahead,int *minq,int *maxq,int *nimin,int *nimax,int *nregmax,int *ncmin,int *ncmax,int *nscmax,int *cpos,int *ipos,int *npos,int *dpos,int *longtime,int *shorttime,int *nitot,int *nctot,int *qcpos,int *qresppos,int *width,int *max_y,int *around_end,int *double_space,int *first_seq,int *last_seq);
int fp(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int region_length,int StartPrevFix,int EndPrevFix);
int get_regression(int nimin,int nimax,int ncmin,int ncmax,int nscmax,int qskip,int cpos,int ipos,int npos,int dpos,int longtime,int shorttime,int nitot, int i, int *past_region, int *in_region, int poke_anal,int around_end,int double_space);
int fp_regr(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int region,int ns,double *ftemptime, int *fix_count);
int tt_regr(int fixation,int temppos,int temptime,int start_region,int end_region,int shorttime,int longtime,int region,int ns,double *ftemptime, int *fix_count,int endsen);
int sec_pass_regr(int fixation,int temppos,int temptime,int start_region,int end_region,int shorttime,int longtime,int region,int ns,int *past_region,int *in_region,int poke_anal, double *ftemptime, int *fix_count,int endsen);
int PrevFixOK(int start_region, int shorttime,int StartPrevFix,int EndPrevFix,int longtime);
int landlaunch(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int region_length,int ncmin,int nimin,int maxcond,int StartPrevFix,int EndPrevFix);
int last_three(int *prev_position); 
void compute_lengths(int nitot,int nimin,int ncmin,int nctot,int nregmax);

struct ir{
	int fixation;		/* fixation number */
	int position;		/* position */
	int region;				/* region */
	int duration;			/* fixation duration */
	} irn[4];



void main();
/******* START OF MAIN PROGRAM HERE ***********/


void main()
{
int changes,newvals;
int sample,temp;
int x,k,j,i,l,jc,ils;
int nimax;
int nitot,nctot;
int nimin;
int nregmax,nscmax,qskip,tnregmax;
int ncmin,ncmax;
int cpos,ipos,npos,dpos;
int longtime, shorttime;
int lookahead,minq, maxq,qcpos,qresppos;
int poke_anal;      /* also use for other special subanalyses */
int cum_grain;
int around_end,double_space;   /*booleans, around_end for whether region can cross line break; double_space for original display*/
int LandlaunchTotal[6];
int LandlaunchTotalAll;
char tch[10];
char string[100];
char c;
int begin_print,end_print;
/* struct date today;*/
int StartPrevFix,EndPrevFix;
int trigger_region,trigger_region_adjustment;
int ni,control_item;		/* number of items in control file */
int xreg;
int tempV;
yoffset = 0;

print_on = 1;		/* start out echoing S file names */
/* ( printf("\nDo you want hard copy? y or n: ");
gets(tch);
if(tolower(tch[0])=='y')
	{
	if ((printer = fopen("prn","w")) == NULL)
		openfail("prn");
	}
else
	{
*/
printf("\nEYEDRY Version %s\n",version);


printf("\nWhat is output trace file name? ");
while((printer=fopen(gets(string),"w")) EQ NULL)
	printf("\nCAN'T OPEN FILE, TRY AGAIN OR QUIT AND CHECK DISK SPACE\n");
printf("\nWriting output on file %s",string);

fprintf(printer,"\nVersion %s\n",version);
/* getdate(&today);
fprintf(printer,"\nDATE: %d/%d/%d\n",today.da_mon,today.da_day,today.da_year);
*/
printf("\nThis version is for normal and eyetracker data on same line");
printf("\nand optionally permits question data to be discarded after each trial.");
printf("\nThis version permits an EXCEPTIONS FILE of item-condition adjustment\npairs.");
printf("\n\nType an identifying string to print out\n");
gets(string);
fprintf(printer,"\n%s\n",string);
printf("\nWhat is the maximum number of fixations on an item\n(60 is assumed if you type a return): ");
gets(string);
if(string[0] == '\0')
	total_samples = 60;
else
	total_samples = atoi(string);
total_samples_plus_start = total_samples + 1;
printf("\nIf %d is too big for the number of items and conditions you have\nthe program will generate a memory allocation error message and halt.\nIf it is too small for some subject, the program will fuss but keep going.\n",total_samples);
fprintf(printer,"\n%d fixations max on one item",total_samples);
printf("\nType name of file containing control info (CR if none). ");
tgets(cfile,stdin);

if(strlen(cfile) != 0)
	{ /* READ IN EXISTING CONTROL FILE*/
	fprintf(printer,"\nStarting .CRN file = %s",cfile);
	newvals = 0;
	if((control = fopen(cfile,"r")) == NULL)
		openfail(cfile);
	fscanf(control,"%d%d",&debug,&qskip);
	fscanf(control,"%d",&lookahead);
	fscanf(control,"%d%d",&minq,&maxq);
	fscanf(control,"%d%d%d%d%d%d%d%d%d%d%d%d",&nimin,&nimax,&nregmax,&ncmin,&ncmax,&nscmax,&cpos,&ipos,&npos,&dpos,&longtime,&shorttime);
	nitot=nimax-nimin+1;
	nctot=ncmax-ncmin+1;
	fscanf(control,"%d%d",&qcpos,&qresppos);
	fscanf(control,"%d%d",&width,&max_y);
	fscanf(control,"%d%d",&around_end,&double_space);
	fscanf(control,"%d%d",&first_seq,&last_seq);
	fscanf(control,"%d%d",&max_in_cond);
	}/*END READ IN CONTROL FILE*/

else
	{  /* GET CONTROL FILE VALUES FROM KEYBOARD INPUT*/
	newvals = 1;
	printf("\nDebug level (0 = no, 1 = getcontrol, 2 = sortsubj, 3 = elsewhere - ");
	debug = atoi(gets(buff));
	printf("Does the question after a sentence have the same COND and ITEM\nnumbers as the sentences and fall on the next line? y or n ");
	qskip = (tolower(*(gets(buff))) EQ 'y')? 2 : 1;
	if(qskip != 2)
		{
		printf("Do you want to eliminate trials on the basis of errors to questions? y or n: ");
		lookahead = (tolower(*(gets(buff))) == 'y')? TRUE : FALSE;
		if(lookahead)
			{
			printf("What is the smallest legal COND number for a question? ");
			minq = atoi(gets(buff));
			printf("What is the largest legal COND number for a question? ");
			maxq = atoi(gets(buff));
			printf("What question response keeps a trial? ");
			lookahead = atoi(gets(buff));
			}
		else
			{
			minq = 0;
			maxq = 0;
			}
		} /* end qskip != 2*/
	 else
		{
		lookahead = 0;
		minq = 0;
		maxq = 0;
		}
	printf("What is smallest numbered experimental item? - ");
	nimin = atoi(gets(buff));

	printf("What is largest numbered experimental item? - ");
	nimax = atoi(gets(buff));
	nitot = nimax-nimin+1;

	printf("How many regions maximum? - ");
	nregmax = atoi(gets(buff));

	printf("What is the smallest condition number (after any exception adjustment)? - ");
	ncmin = atoi(gets(buff));

	printf("What is the largest condition number (after exception adjustment)? -" );
	ncmax = atoi(gets(buff));
	nctot = ncmax-ncmin+1;

	printf("How many subconditions maximum for any one item? - ");
	nscmax = atoi(gets(buff));

	printf("What field is the condition number in? ");
	cpos = atoi(gets(buff));
	printf("What field is the item number in? ");
	ipos = atoi(gets(buff));
	printf("What field is the number-of-fixations number in? ");
	npos = atoi(gets(buff));
	printf("What field do the data start in? ");
	dpos = atoi(gets(buff));
	printf("Longest fixation time, msec (truncate if above): ");
	longtime = atoi(gets(buff));
	printf("Shortest fixation time, msec (discard if below): ");
	shorttime = atoi(gets(buff));
	if(lookahead)
		{
		printf("What field is the question condition number in? ");
		qcpos = atoi(gets(buff));
		printf("What field is the question response in? ");
		qresppos = atoi(gets(buff));
		}
	else
		{
		qcpos = 0;
		qresppos = 0;
		}
	printf("What is the screen width in characters? 60, 72, 80, or 160 (Eyelink): ");
	width = atoi(gets(buff));
	printf("What is the maximum number of lines of text? ");
	max_y = atoi(gets(buff));
	printf("Do you want to permit regions to wrap around end of a line? y or n: ");
	around_end = (tolower(*(gets(buff))) EQ 'y')? 1 : 0;
	if(around_end == 1)
		printf("\nWARNING! Deviation from predicted parameters will not be computed\ncorrectly, nor will ms/char values be right for the region\nthat goes across two lines!!!\n");
	printf("Did your .sen/.stm file have blank lines between lines of text? y or n: ");
	double_space = (tolower(*(gets(buff))) EQ 'y')? 1 : 0;
	printf("Do you want to analyze just some of your trials (eg 1st half)? y or n: ");
	if(tolower(*(gets(buff))) != 'y')
		{
		first_seq = last_seq = 0;		/* analyze all */
		printf("Do you want to analyze just the first N trials in each condition? y or n: ");
		if(tolower(*(gets(buff))) != 'y')
			max_in_cond = 0;
		else
			{
			printf("\nHow many trials do you want to analyze in each condition? ");
			scanf("%d",&max_in_cond);
			}
		}
	else
		{
		printf("\nCAUTION: In specifying trials to examine, count questions as well as");
		printf("\nexperimental items. E.g., if you want to look at the 5th through 10th");
		printf("\ntrials and each sentence was followed by a question then you should");
		printf("\nanswer 9 for the first and 19 for the second (2n - 1).");
		printf("\nWhich is the first trial in sequence you want to examine? ");
		scanf("%d",&first_seq);
		printf("Which is the last trial in sequence you want to examine? ");
		scanf("%d",&last_seq);
		}	
	}/* END GET CONTROL VALUES FROM KEYBOARD INPUT*/

while((changes = correct(&debug,&qskip,&lookahead,&minq,&maxq,&nimin,&nimax,&nregmax,&ncmin,&ncmax,&nscmax,&cpos,&ipos,&npos,&dpos,&longtime,&shorttime,&nitot,&nctot,&qcpos,&qresppos,&width,&max_y,&around_end,&double_space,&first_seq,&last_seq)) > 0)
	;
tnregmax = nregmax;		/* hold them for future need */
if((changes != 0) || newvals)
{
printf("\nWhat file name do you want to save these values as (CR if none)? ");
tgets(cfile,stdin);
fprintf(printer,".CRN file = %s\n",cfile);
if(strlen(cfile) != 0)
	{  /* WRITE NEW CONTROL FILE*/
	if ((control = fopen(cfile,"w")) == NULL)
		openfail(file);
	fprintf(control,"%d %d \n",debug,qskip);
	fprintf(control,"%d\n",lookahead);
	fprintf(control,"%d %d\n",minq,maxq);
	fprintf(control,"%d %d %d %d %d %d %d %d %d %d %d %d\n",nimin,nimax,nregmax,ncmin,ncmax,nscmax,cpos,ipos,npos,dpos,longtime,shorttime);
	fprintf(control,"%d %d\n",qcpos,qresppos);
	fprintf(control,"%d %d\n",width,max_y);
	fprintf(control,"%d %d\n",around_end,double_space);
	fprintf(control,"%d %d\n",first_seq,last_seq);
	fprintf(control,"%d\n",max_in_cond);
	fclose(control);
	}  /* END WRITE NEW CONTROL FILE*/
}
printf("What is the name of the file that lists data files? ");
while((datalst=fopen(gets(file),"r")) EQ NULL)
	printf("\nBad file name, try again.\n");
fprintf(printer,"datalst = %s\n",file);
nsub = 0;
while((c = fgetc(datalst)) != EOF)	/* count the subjects */
	{
/*	printf("%c",c);*/
	if(c == '\n')
		nsub++;
	}
rewind(datalst);
printf("\n%d subjects\n",nsub);
printf("Any exceptions file? y or n: ");
exceptflag = (tolower(*gets(buff)) EQ 'y') ? TRUE : FALSE;
if(exceptflag)
	{
	printf("What is the exceptions file name? ");
	while((except=fopen(gets(file),"r")) EQ NULL)
		printf("\nBAD FILE NAME, TRY AGAIN\n");
	fprintf(printer,"Exceptions file %s\n",file);
	while(fscanf(except,"%d %d",&i,&j) != EOF)
		{
		fprintf(printer,"item %d condition adjustment %d\n",i,j);
		vexcept[i-nimin] = j;	/* vector of condition adjustment values */
		}
	}
printf("\nAssuming y offset is 0.\n");
if(mspc == 2)
	first_region_for_regression = 0;
if((longs = (int *)(calloc(total_samples+1,sizeof(int)))) == NULL)
	oops("longs");
if((shorts = (int *)(calloc(total_samples+1,sizeof(int)))) == NULL)
	oops("shorts");

if((C = (int *)(calloc(nitot*nscmax*nregmax,sizeof(int))))==NULL)
	oops("C");
if((NR = (int *)(calloc(nitot*nscmax,sizeof(int))))==NULL)
	oops("NR");
ni = getcontrol(nimin,nitot,ncmin,nctot,nregmax,nscmax);	/* get the control list into C, return number of items */
printf("\n%d lines in control file",ni);
fprintf(printer,"***********************************************************\n\n");


while(1)
{
printf("\nWhich analysis?\n  1 = first (or second) fixation\n  2 = first pass time\n  3 = total time\n  4 = first pass regressions out\n  5 = regressions in\n  6 = prob of first-pass fixation (or duration of fix before or after skip or land)\n  7 = number of fixations\n  8 = second pass times\n  9 = eyepoke\n 10 = eyegaze\n 11 = landing position or launch site\n 12 = position as function of time\n 13 = time from entering region to first going PAST it\n 14 = first fixation or saccade after LEAVING region (spillover)\n 15 = saccade matrix (from region to region)\n 16 = total gaze\n 17 = Landing/launch position\n 18 = inhibition of return stuff\n 19 = vector of entering and leaving\n 20 = file of region lengths\n 0 TO QUIT: ");
anal = atoi(gets(string));
if(!anal)
	goto end;
fprintf(printer,"type of analysis %d\n",anal);
printf("\nType an identifying string to print out\n");
gets(string);
fprintf(printer,"\n*****\n%s\n*****\n",string);

/*******SETTING OPTIONS **************************/
cond_reg = cond_fix = 0; /*restore default*/
/* check whether to count zero observations or not */
if((anal >= 4 && anal <8) || (anal >8 && anal <= 12) || anal == 14 || anal == 16)
/* i.e. fp_ro, ri, prob fp fix, #fix, poke, gaze, landing pos,
	pos as func time, spillover or saccade matrix*/
	throwaway_zero = 2;                     /* irrelevant */
else if(anal == 1 || anal == 17)   /* 1st fix*/
	throwaway_zero = 1;                     /* force it true */
else if(anal == 18 || anal == 19 || anal == 20)
	throwaway_zero = 0;
else /* first pass, second pass, gopast, total time or first_going_past_region */
	{
	printf("\nThrow away zero fixation values? y or n: ");
	if(tolower(*gets(buff)) == 'n')
		throwaway_zero = 0;
	else
		throwaway_zero = 1;
	}
if(anal < 18)
	printf("\nThrowaway_zero %d (0 is keep zeros, 1 is throw them away)\n",throwaway_zero);
/* end checking if count zero observations or not*/

	
if(anal == 1)		/* first fixation */
	{
	printf("Which analysis:\n1 = all initial fixations\n2 = exactly one fixation\n3 = initial one of multiple fixations\n4 = second of more than one fixation\n5 = last fixation prior to entering region:\n6 = conditionalize on presence/absence of fixation in specified region	type 1, 2, 3, 4, or 5: ");
	while((poke_anal = atoi(gets(string))) == 0)
		printf("\nNope, type a number! ");
	}

if(anal == 6) 	/* prob of fix */
	{
	printf("Which analysis:\n1 = prob of one or more fixations\n2 = prob of exactly one fixation\n3 = duration of fixation immediately before skip\n4 = duration of fixation immediately after skip\n5 = duration of fixation immediately before landing\n6 = duration of fixation immediately after landing\nType 1, 2, 3, 4, 5, or 6: ");
	while((poke_anal = atoi(gets(string))) == 0)
		printf("\nNope, type a number! ");
	}

if(anal == 8)  /* second pass*/
	{
	printf("Which analysis:\n 1 = include only time in region after going past it\n 2 = include all re-reading time after leaving region, left or right: \n 3 = include only time in region after leaving it to left, before going past: \n 4 = include only time in region after having first entered a later, specified, region: ");
	while((poke_anal = atoi(gets(string))) == 0)
		printf("\nNope, type a number! ");
	if(poke_anal == 4)
		{
		printf("\nHI TIM!\b");
		do
			printf("What is the trigger region (count from 1; region must be greater than 1): ");
		while ((trigger_region = atoi(gets(string))) < 2 && trigger_region > nregmax); 
		}
	printf("How many characters do you want the start of the trigger region moved left (0 or more): ");
	trigger_region_adjustment = atoi(gets(string));
	trigger_region = trigger_region-1;	/* count from zero */
	
	}

/* setting cumulate or average option */
if(anal < 4 || anal >= 8)
	{/*everything but fp_ro, ri, prob fp fix, and # fix*/
	if(anal == 1 || anal == 9 || anal == 11 || anal == 12 || anal == 14 || anal == 15 || anal == 16 || anal == 17  || anal == 18 || anal == 19 || anal == 20)
		/*  1st fix,     poke         landing pos  pos as func time spillover  matrix totalgaze */
		{
		avg = 0;
		if(anal == 19)
			{
			printf("Do you want first pass gaze times only (vs. all initial entries)? y or n: ");
			if((c = tolower(*gets(buff))) == 'y')
				poke_anal = 1;
			else
				poke_anal = 0;			/* 0 for all entries, 1 for just first pass entries */
			}
		}
	else
		{/* fp, tt, gaze, second pass, 1st_going_past_region */
		printf("Do you want to CUMULATE or AVERAGE multiple fixations in a region? c or a- ");
		avg = (tolower(*gets(buff))) EQ 'a'? 1 : 0;
		if(avg)
			fprintf(printer,"averaging multiple phrases in a region\n");
		else
			fprintf(printer,"cumulating multiple phrases in a region\n");
		} /*END else fp, tt, gaze, second pass, or 1st_going_past_region */

		/*raw times, ms/c or dev from reg?*/
		if(anal == 2 || anal == 3 || anal == 8)
			{/*fp or tt or 2nd pass*/
			printf("RAW times, MS/char, or DEVIATION from regression: r, m, or d: ");
			if((c = tolower(*gets(buff))) == 'd')
				mspc = 2;
			else if (c == 'm')
				mspc = 1;
			else
				mspc = 0;
			}  /*END fp or tt or 2nd pass*/
		else if(anal == 1 || anal == 9 || anal == 10 || anal == 13 || anal == 16)
			{ /*1st fix, poke, gaze, 1st_going_past_region, total gaze */
			printf("Do you want to keep RAW times or convert to MSEC/CHAR? r or m: ");
			mspc = (tolower(*gets(buff))) EQ 'm' ? 1 : 0;
			}
		else if(anal == 15)
			mspc = 0;
		else
			mspc = 1; /* fake it, force to x10 */
		 /* done with raw times, ms/c or dev from reg*/

		 cond_reg = cond_fix = 0; /*restore default*/

       /* conditionalize on regressions */
		if(anal <= 3)
			{ /* first fix, first pass, total time */
			printf("Conditionalize on presence/absence of regression in critical region? y or n: ");
			cond_reg = (tolower(*gets(buff))) == 'y' ? 1 : 0;       /* 0 default */
			if(cond_reg)
				{
				do
					{
					printf("Which region do you want to conditionalize on? 1 - %d:  ",nregmax);
					gets(buff);
					which_cond_reg = atoi(buff);
					}
				while (which_cond_reg <= 0 || which_cond_reg > nregmax);
				which_cond_reg--;		/* count regions from zero as always */
				printf("Keep (only) or Eliminate trials on which there was\na regression from region %d? k or e: ",which_cond_reg+1);
				gets(buff);
				cond_reg = (tolower(buff[0])) == 'k' ? 1 : 2;	/* 1 keep, 2 eliminate */
				} /*end if condreg*/
			} /* END anal <=3  done with conditionalize on regressions*/

				/* conditionalize on fixation in critical region */
		if(anal <= 3)
			{ /* first fix, first pass, total time */
		  printf("Conditionalize on presence/absence of fixation in critical region? y or n: ");
			cond_fix = (tolower(*gets(buff))) == 'y' ? 1 : 0;       /* 0 default */
			if(cond_fix)
				{
				do
					{
					printf("Which region do you want to conditionalize on? 1 - %d:  ",nregmax+1);
					gets(buff);
					which_cond_fix = atoi(buff);
					}
				while (which_cond_fix < 1 || which_cond_fix > nregmax+1);
				which_cond_fix--;		/* count regions from zero as always */
				printf("Keep (only) or Eliminate trials on which there was\na fixation in region %d? k or e: ",which_cond_reg+1);
				gets(buff);
				cond_fix = (tolower(buff[0])) == 'k' ? 1 : 2;	/* 1 keep, 2 eliminate */
				} /*end if condfix*/
			} /* END anal <=3  done with conditionalize on regressions*/


	}/* end if(anal < 4 || anal >= 8) */
else
	{  /* fp_ro, ri, prob fp fix, and # fix*/
	mspc = 0;
	avg = 0;                /* for regressions analysis */
	}  /* END setting cumulate or average option */

gazeanal = 0;

if(anal == 2)
	{
	printf("What is the upper summed cutoff for first pass time? 2000 is default: ");
	gets(buff);
	if(strlen(buff) == 0)
		fpcutoff = 2000;
	else
		fpcutoff = atoi(buff);
	}

if(anal == 3)
	{
	printf("What is the upper summed cutoff for total time? 4000 is default: ");
	gets(buff);
	if(strlen(buff) == 0)
		ttcutoff = 4000;
	else
		ttcutoff = atoi(buff);
	}


if(anal == 17)		/* kludge for landing and launch sites */
	{
	do
		{
		printf("Which is the critical region? - ");
		which_reg = atoi(gets(buff))-1;
		}
	while(which_reg > tnregmax);
	fprintf(printer,"critical region is %d\n",which_reg+1);
	}
if(anal == 9 || anal == 10 || anal == 12 || anal == 14 || anal == 16)       /* a little kludge for eyepoke */
	{ /* poke, gaze, pos as func of time; spillover; totalgaze */
/* also kludge for landing/launch site */
	gazeanal = 1;
	tnregmax = nregmax;
	if(anal == 9)   /* eyepoke */
		nregmax = 7;            /* storing 7 numbers for each trial; 4 is first fix in crit */
	else if(nregmax < 4)
		nregmax = 4;    /* to allocate room for eyegaze and next fix */
	do
		{
		printf("Which is the critical region? - ");
		which_reg = atoi(gets(buff))-1;
		}
	while(which_reg > tnregmax);
	fprintf(printer,"critical region is %d\n",which_reg+1);
	if(anal != 12)
		{
		printf("How many characters (maximum) can the start of a region be moved left? ");
		move_limit = atoi(gets(buff));
		fprintf(printer,"adjusting %d characters left\n",move_limit);
		}
	if(anal == 9)
		{
		printf("Which analysis:\n 1 = fixation durations\n 2 = all saccade lengths\n 3 = nonregressive saccades, before first regression\n 4 = probability of a forward saccade: ");
		while((poke_anal = atoi(gets(string))) == 0)
			printf("\nNope, type a number! ");
		if(poke_anal == 1)
			{
			printf("Do you want to keep fixations after critical region even if\n  there is no fixation in the critical region? y or n: ");
			keep_to_right = (tolower(*(gets(buff))) == 'y')? TRUE : FALSE;
			}
		else
			keep_to_right = FALSE;		/* for distances */
     	if(poke_anal == 4)
	      mspc = 1;
		}
	else if(anal == 12)
		{ /*position as a function of time*/
		printf("Report fixation positions relative to what?\n 0 = start of region\n 1 = first fixation in region: ");
		poke_anal = atoi(gets(string));
		if(poke_anal == 0)
			fprintf(printer,"\nPosition as a function of time relative to start of region");
		else
			fprintf(printer,"\nPosition as a function of time relative to first fixation in region");
		printf("\nDo you want cumulative (C. Scheepers) or noncumulative version:\n 0 = cumulative\n 1 = noncumulative: ");
		temp = atoi(gets(string));
		if(temp == 1)
			{
			poke_anal += 2;
			fprintf(printer," - cumulative version\n ");
			}
		printf("What is sample size in msec? Type 10, 20, 50, whatever: ");
		cum_grain = atoi(gets(string));
		printf("\nHow many ms of cumulative data do you want? ");
		cum_positions = atoi(gets(string));
		cum_positions /= cum_grain;
		printf("\n  Recording %d samples",cum_positions);

		}
	else if(anal == 14)
		{ /*spillover*/	/* poke_anal 0 = keep last, duration, forward; 1 = eliminate last, time forward;
			2 = keep last, length, forward; 3 = eliminate last, length, forward; 4, 5, 6, 7 same but either
			forward or backward; 9-16, same thing but demand single fixation on critical region*/
		printf("\nDo you want to eliminate the last fixation on a sentence?\nType y or n: ");
		poke_anal = (tolower(*(gets(buff))) == 'y')? 1 : 0;
		printf("\nDo you want to record fixation Duration or saccade Length of the first saccade\nout of each region? (Doesn't work right going across doublespace lines)\nType d or l: ");
		if((x = tolower(*gets(buff))) == 'l')
			poke_anal += 2;	
		else if(x != 'd')
			printf("\nNot a legal response; setting value to duration.\n");
		printf("\nDo you want to permit only Forward-going saccades or allow Regressions as well?\nType f or r: ");
		if((x = tolower(*gets(buff))) == 'r')
			poke_anal += 4;	
		else if(x != 'f')
			printf("\nNot a legal response; setting value to forward-going.\n");
		printf("\nDo you want to demand only single fixation in the critical region?\nType y or n: ");
		if((x = tolower(*gets(buff))) == 'y')
			poke_anal += 8;	
		else if(x != 'n')
			printf("\nNot a legal response; setting value to multiple fixations OK.\n");
		if((poke_anal/2)%2 == 0)
			{					/* spillover durations */
			printf("Do you want to keep RAW times or convert to MSEC/CHAR?\nType r or m: ");
			mspc = (tolower(*gets(buff))) EQ 'm' ? 1 : 0;
			}
		else
			mspc = 1;			/* kludge to get decimal points for saccade lengths */
		}
	}
else if(anal == 7)      /* number of fixations */
  {
    printf("Which analysis:\n 1 = count fixations prior to leaving region\n 2 = count all fixations in region?  --  ");
		while((poke_anal = atoi(gets(string))) == 0)
			printf("\nNope, type a number! ");
    nregmax = tnregmax;
  }
else if(anal == 11)
	{
	printf("Which analysis:\n 1 = position of first fixation\n 2 = position of second fixation\n 3 = launch site:  ");
	while((poke_anal = atoi(gets(string))) == 0)
		printf("\nNope, type a number! ");
	}
else   /* not 9, 10, 12 or 14; not 7 */
	nregmax = tnregmax;

if(anal == 13)
	{ /* first going past region*/
	printf("Which analysis:\n 1 = All from first entering region to first going past\n 2 = Time spent in region from first entering to first going past\n 3 = Time spent outside of region after entering to first going past: ");
	while((poke_anal = atoi(gets(string))) == 0)
		printf("\nNope, type a number! ");
	}
if(anal == 15)
	{
	printf("\nWhat kind of matrix?\n 1 = all saccades\n 2 = only saccades not following regression: ");
	which_matrix = atoi(gets(string));
	}


	StartPrevFix = 0;			/* default */

/* check for previous fixation filter */
if(anal <= 3 || (anal == 6 && poke_anal <= 2) || anal == 17 || (anal == 11 && poke_anal <= 2))
	{
	printf("Conditionalize on position of last fixation before each region? y or n: ");
	if(tolower(*gets(buff)) == 'y')
		{
		printf("\nWhat is the earliest fixation position you will accept\n  (specify in characters before start of region): ");
		StartPrevFix = atoi(gets(string));
		printf("\nWhat is the last fixation position you will accept\n  (specify in characters before start of region): ");
		EndPrevFix = atoi(gets(string));
		}
	}



/*Which output files to print and what to call them */
if(anal < 19)
	printf("\nType in names of the output files you want. Just hit ENTER for no.\n");
if(anal != 12 && anal != 15 && anal != 17 && anal < 18) /* subj by items file */
	{ /*not pos as func of time nor matrix nor lengths */
	printf("\nFile of item X subject combinations: ");
	tgets(AllfileName,stdin);
	if(strlen(AllfileName) > 0 && strlen(AllfileName) < 2 && (AllfileName[0] == 'y' || AllfileName[0] == 'n'))
		{
		printf("\b\nNO, DUMMY, READ THE INSTRUCTIONS: Type in a name or nothing.\nTry it again: ");
		tgets(AllfileName,stdin);
		}
	if(strlen(AllfileName) > 0)
		{
		printf("Do you want All trials written, or just trials with Observations?\n  Type a or o: ");
		if(tolower(*gets(buff)) == 'a')
			ixsopt = 1;
		else
			ixsopt = 0;
		printf("Do you want Wide ouput (all regions in one row) or Narrow (one row per region)?\n  Type w or n: ");
		if(tolower(*gets(buff)) == 'w')
			wide = 1;
		else
			wide = 0;

		}
	}
if(anal < 18)
	{
	printf("Subject by subject file, one condition per line (not systat): ");
	tgets(SubfileName,stdin);
	}
else if (anal == 18)		/* inhibition of return analysis */
	{
	printf("Name of subject-by-subject file of fixation information vectors: ");
	tgets(SubfileName,stdin);
	printf("What is the maximum number of regressions you will allow in an item? ");
	maxregressions = atoi(gets(string));
	}
else if(anal == 19)
	{
	printf("Name of file to write vectors of entering and leaving times in: ");
	tgets(AllfileName,stdin);
	}
if(anal != 12 && anal != 15 && anal != 17 && anal < 18)
	{
	printf("Subject by subject file, formatted for Systat: ");
	tgets(SysSubfileName,stdin);
	}

/*items file*/
if(anal != 12 && anal != 17 && anal < 18)		/* add later for Jane */
	{
	printf("Item by item file, one condition per line (not systat): ");
	tgets(SenfileName,stdin);
	if(anal != 15)
		{
		printf("Item by item file, formatted for Systat: ");
		tgets(SysSenfileName,stdin);
		}
	}/* done with items file*/
	
if(strlen(AllfileName) > 2)
	{
	if((Allfile = fopen(AllfileName,"w")) == 0)
		openfail(AllfileName);
	else
		fprintf(printer,"Subj X Items file %s\n",AllfileName);
	}
if(strlen(SubfileName) > 2)
	{
	if((Subfile = fopen(SubfileName,"w")) == 0)
		openfail(SubfileName);
	else
		fprintf(printer,"\nSubjects file %s\n",SubfileName);
	}
if(strlen(SysSubfileName) > 2)
	{
	if((SysSubfile = fopen(SysSubfileName,"w")) == 0)
		openfail(SysSubfileName);
	else
		fprintf(printer,"Subjects file for systat %s\n",SysSubfileName);
	}
if(strlen(SenfileName) > 2)
	{
	if((Senfile = fopen(SenfileName,"w")) == 0)
		openfail(SenfileName);
	else
		fprintf(printer,"Items file %s\n",SenfileName);
	}
if(strlen(SysSenfileName) > 2)
	{
	if((SysSenfile = fopen(SysSenfileName,"w")) == 0)
		openfail(SysSenfileName);
	else
		fprintf(printer,"Items file for systat %s\n",SysSenfileName);
	}

/* CALLOC space for necessary variables */
/*printf("\nCALLOC'ing for nctot = %d nitot = %d nscmax = %d nregmax = %d\n",nctot,nitot,nscmax,nregmax);*/
if(anal < 20)
	{
	printf("Do you want information about long and short times printed? y or n -");
	chatter = (tolower(*(gets(buff))) == 'y') ? TRUE : FALSE;
	}

if(anal < 18)
{
if((V = (int *)(calloc(nitot*nscmax*nregmax,sizeof(int))))==NULL)
	oops("V");
if((NV =  (int *)(calloc(nitot*nscmax*nregmax,sizeof(int))))==NULL)
	oops("NV");
if((CUMV =  (int *)(calloc(nitot*nscmax*nregmax,sizeof(int))))==NULL)
	oops("CUMV");
if((CUMNV =  (int *)(calloc(nitot*nscmax*nregmax,sizeof(int))))==NULL)
	oops("CUMNV");
if((CONDV =  (int *)(calloc(nctot*nregmax,sizeof(int))))==NULL)
	oops("CONDV");
if((CONDNV =  (int *)(calloc(nctot*nregmax,sizeof(int))))==NULL)
	oops("CONDNV");
if((CUMCV =  (int *)(calloc(nctot*nregmax,sizeof(int))))==NULL)
	oops("CUMCV");
if((CUMCNV =  (int *)(calloc(nctot*nregmax,sizeof(int))))==NULL)
	oops("CUMCNV");
if((CUMCVT = (int *)(calloc(nctot*nregmax,sizeof(int))))==NULL)
	oops("CUMCVT");
if((CUMCNVT =  (int *)(calloc(nctot*nregmax,sizeof(int))))==NULL)
	oops("CUMCNVT");

}/* end of if < 18 */

/* all analyses */

if((ITEMCOND =  (int *)(calloc(nitot*nscmax,sizeof(int))))==NULL)
	oops("ITEMCOND");
if((ITEMSEQ =  (int *)(calloc(nitot*nscmax,sizeof(int))))==NULL)
	oops("ITEMSEQ");

if(anal == 12)		/* only if doing cumulative */
{
if((TCUMPOS = (int *)(calloc(nitot*nscmax*cum_positions,sizeof(int))))==NULL)
	oops("TCUMPOS");
if((CUMPOS = (int *)(calloc(nctot*cum_positions,sizeof(int))))==NULL)
	oops("CUMPOS");
if((TOTAL_CUMPOS = (float *)(calloc(nctot*cum_positions,sizeof(float))))==NULL)
	oops("CUMPOS");
if((COUNT_CUMPOS = (int *)(calloc(nctot*cum_positions,sizeof(int))))==NULL)
	oops("COUNT_CUMPOS");
if((COUNT_TOTAL_CUMPOS = (int *)(calloc(nctot*cum_positions,sizeof(int))))==NULL)
	oops("COUNT_TOTAL_CUMPOS");
}

if(anal == 15)		/* only if doing saccade matrix */
{
if((CUM_MATRIX = (int *)(calloc(nctot*nregmax*nregmax,sizeof(int))))==NULL)
	oops("CUM_MATRIX");
if((S_MATRIX = (int *)(calloc(nctot*nregmax*nregmax,sizeof(int))))==NULL)
	oops("S_MATRIX");
if((I_MATRIX = (int *)(calloc(nitot*nscmax*nregmax*nregmax,sizeof(int))))==NULL)
	oops("I_MATRIX");
}

if(anal == 17)			/* land, launch; 6 x 8; top 5x8 is word length x land
			site, 0 - 7+; bottom row is launch site, chars before space that starts region */
{
if((CUM_MATRIX = (int *)(calloc(nctot*6*8,sizeof(int))))==NULL)
	oops("CUM_MATRIX");
if((S_MATRIX = (int *)(calloc(nctot*6*8,sizeof(int))))==NULL)
	oops("S_MATRIX");
if((I_MATRIX = (int *)(calloc(nitot*nscmax*6*8,sizeof(int))))==NULL)
	oops("I_MATRIX");
}

/* done callocing space*/

/* kludge, zero landing & launch info */

if(anal == 17)
	{
	for(i=0;i<nctot;i++)
		for(j=0;j<6;j++)
			{
			for(k=0;k<8;k++)
				*(CUM_MATRIX + i*8*6 + j*8 + k) = 0;
			}
	}

if(debug != 0)
	{
	printf("\n nimax = %d nscmax = %d\n",nimax,nscmax);
/*	if(getchar() == 'q')
		exit(1);*/
	}

if(strlen(AllfileName) > 2 && anal != 20)
	if (wide)
		{
		fprintf(Allfile,"seq,subj,item,cond");	
		for(xreg = 0;xreg < nregmax; xreg++)
			fprintf(Allfile,",R%d",xreg+1);
		fprintf(Allfile,"\n");
		}
	else
		fprintf(Allfile,"seq,subj,item,cond,region,datum\n");
if(anal == 20)			/* just lengths */
	{
	printf("Name of file to write region lengths to: ");
		tgets(AllfileName,stdin);
	if(strlen(AllfileName) > 0 && strlen(AllfileName) < 2 && (AllfileName[0] == 'y' || AllfileName[0] == 'n'))
		{
		printf("\b\nNO, DUMMY, READ THE INSTRUCTIONS: Type in a name or nothing.\nTry it again: ");
		tgets(AllfileName,stdin);
		}
	if(strlen(AllfileName) > 2)
		{
		if((Allfile = fopen(AllfileName,"w")) == 0)
			openfail(AllfileName);
		else
			fprintf(printer,"Length file %s\n",AllfileName);
		}
	printf("Do you want Wide ouput (all regions in one row) or Narrow (one row pre region)?\n  Type w or n: ");
	if(tolower(*gets(buff)) == 'w')
		wide = 1;
	else
		wide = 0;
	compute_lengths(nitot,nimin,ncmin,nctot,nregmax);
	fclose(Allfile);
	}

else				/* don't loop for lengths */
for(i=0;i<nsub;i++)
	{

/* pft kludge 
printf("\nNEXT SUBJECT %d",i+1); */

/*      printf("\nSubject %d; what is y offset? ",i+1);
	yoffset = atoi(gets(string));*/
	cleararrays(nitot,nctot,nscmax,nregmax,i);
	longcount = shortcount = total_fixation_count = 0;

	/* sortsubject is a FUNCTION FOR READING INDIVIDUAL SUBJECT DATA, SORTING INTO*/
	if(sortsubject(i,nimin,nimax,ncmin,ncmax,nscmax,qskip,cpos,ipos,npos,dpos,longtime,shorttime,lookahead,minq,maxq,qcpos,qresppos,nitot,poke_anal,cum_grain,nregmax,nctot,around_end,double_space,StartPrevFix,EndPrevFix,trigger_region,trigger_region_adjustment) == 0)
		goto early_end;		/* error return */
	fprintf(printer,"\nlongcount %d shortcount %d",longcount,shortcount);
	if(anal == 3)				/* total time */
		{
		fprintf(printer," total number fixations %d",total_fixation_count);
		if(total_fixation_count != 0)
			{
			fprintf(printer,"\nproportion long times %f proportion short times %f",(float)longcount/(float)total_fixation_count,(float)shortcount/(float)total_fixation_count);
			sum_prop_long+= (float)longcount/(float)total_fixation_count;
			sum_prop_short+= (float)shortcount/(float)total_fixation_count;
			}
		}


/* kludge for Jane */
	if(anal != 12 && anal != 15 && anal != 17 && anal < 18)    /* not for position as function of time or matrix or Jane*/
	{
/* WRITE ITEM BY SUBJECTS INFORMATION */
	if(strlen(AllfileName) > 2)
		for(j = 0; j < nitot; j++)
			for(k = 0; k < nscmax; k++)
			{
			ti1 = k*nitot + j;
			if(*(ITEMCOND + ti1) || ixsopt)		/* make writing of all cond/item pairs optional - if ixsopt is 1 */
			{
			if(wide)
				{
				fprintf(Allfile,"%d,%d,%d,%d",*(ITEMSEQ+ti1),i+1,j+1,*(ITEMCOND + ti1));
				}
			for(l = 0; l < nregmax; l++)
				{
				if(!wide)
					fprintf(Allfile,"%d,%d,%d,%d,%d,",*(ITEMSEQ+ti1),i+1,j+1,*(ITEMCOND + ti1),l+1);
				ti2 = l*nitot*nscmax + k*nitot + j;
				if(*(NV+ti2) || !throwaway_zero)	/* output zero when throwaway_zero false i.e. keeping zeros */
					{
					tempV = *(V + ti2);		/* fudge to get 1's out for oreg, ireg */
					if((anal == 4 || anal == 5) && tempV == 100)
						tempV = 1;
					if(wide)
						{
						if(mspc || (anal == 9 && poke_anal >= 2 && l != 3))
							{
							if(avg & (*(NV + ti2)) > 0)
								fprintf(Allfile,",%.2f",(float)((*(V+ti2)))/((float)((*(NV+ti2))))*10.0);
							else
								fprintf(Allfile,",%.2f",((float)*(V+ti2))/10.0);
							}
						else
							{  /* ~mspec && (anal != 9 (eyepoke) or anal = 9 but poke_anl < 2) */
							if(avg & (*(NV + ti2)) > 0)
								fprintf(Allfile,",%d",(*(V+ti2))/(*(NV+ti2)));
							else
								{
/*								fprintf(Allfile,",%d",*(V+ti2));*/
								fprintf(Allfile,",%d",tempV);		/* kludge to get ireg, oreg out right */
								}
							} /* end ~mspec && ... */
						}
					else		/* not wide */
						{
						if(mspc || (anal == 9 && poke_anal >= 2 && l != 3))
							{
							if(avg & (*(NV + ti2)) > 0)
								fprintf(Allfile,"%.2f\n",(float)((*(V+ti2)))/((float)((*(NV+ti2))))*10.0);
							else
								fprintf(Allfile,"%.2f\n",((float)*(V+ti2))/10.0);
							}
						else
							{  /* ~mspec && (anal != 9 (eyepoke) or anal = 9 but poke_anl < 2) */
							if(avg & (*(NV + ti2)) > 0)
								fprintf(Allfile,"%d\n",(*(V+ti2))/(*(NV+ti2)));
							else
								{
/*								fprintf(Allfile,"%d\n",*(V+ti2)); */
								fprintf(Allfile,"%d\n",tempV);
								}
							} /* end ~mspec && ... */
						}
					} /* end if * (NC+ti1)) */
				else
					{
					if(wide)
						fprintf(Allfile,",");
					else
						fprintf(Allfile,"\n");
					}
				}  /* end l = 0; l < nregmax; l++ */
			if(wide)
				fprintf(Allfile,"\n");
			}
			} /* end for (k = 0; k < nscmax; k++ */
	/* DONE WRITING ITEM BY SUBJECTS FILE; still in not anals 12 or 15 or 18*/

	/* counting things for item by item file */
	for(j=0;j<nitot;j++)
		for(k=0;k<nscmax;k++)
			{
			ti2 = k * nitot + j;
			if(debug == 3)
				printf("\n rel item %d rel scond %d itemcond %d",j+1,k+1,*(ITEMCOND+ti2));
			if(((*(ITEMCOND+ti2)-ncmin)%nscmax) EQ k)	/* data for this sen & cond */
				{
				for(l=0;l<nregmax;l++)
					{
					ti1 = l*nscmax*nitot + k*nitot + j;
					if((*(NV + ti1) != 0) || (throwaway_zero == 0))			/* cumulate when have data or if don't want to throw away zeros */
						{
						if(avg && (*(NV+ti1) != 0))
							*(CUMV+ti1) += (*(V+ti1))/(*(NV+ti1));
						else
							*(CUMV+ti1) += *(V+ti1);
						(*(CUMNV+ti1))++;
						if(debug==3)
							printf("\ncumulating in main; item %d cond %d segment %d CUMV = %ld, CUMNV = %d",j+1,k+1,l+1,*(CUMV+ti1),*(CUMNV+ti1));
						} /* end  if((*(NV + ti1) != 0) || throwaway_zero == 0)  */
					} /* end for (l = 0; l < nregmax; l++ */
				} /* end for if(ITEMCOND...) */
			} /* end of item, cond loop */

	/*WRITE SUBJECTS FILE; still in not anals 12 or 15 or 18 */
	for(j=0,jc=ncmin-1;jc<ncmax;j++,jc++)
		collapsecond(j,jc,nimin,nimax,nscmax,nregmax,nitot,nctot);
	if(anal == 10 || anal == 14 || anal == 16)	/* eyegaze,totalgaze, spillover, just middle */
		{
		begin_print = 3;
		end_print = 4;
		}
	else  /*anything but eyegaze or spillover */
		{
		begin_print = 0;
		end_print = nregmax;
		}

	if(strlen(SubfileName) > 2 || strlen(SysSubfileName) > 2) 	/* not for position as function of time */
		{
		if(strlen(SysSubfileName) > 2 && i == 0)			/* write variable names */
			{
			for(jc=ncmin-1;jc<ncmax;jc++)
				for(j=begin_print;j<end_print;j++)
					fprintf(SysSubfile,"C%dR%d  ",jc+1,j+1);
			fprintf(SysSubfile,"\n");
			}
					
		for(j=0,jc=ncmin-1;jc<ncmax;j++,jc++)
			{
			if(strlen(SubfileName) > 2)
				fprintf(Subfile,"%5d%5d",i+1,jc+1);
			for(k = begin_print; k < end_print; k++)
				{
				ti1 = k*nctot + j;
				if(*(CONDNV+ti1))
					{
         	if(mspc || (anal == 9 && poke_anal >= 2 && k != 3))
						{
						if(strlen(SubfileName) > 2)
							fprintf(Subfile,"%7.1f%3d",(float)(*(CONDV+ti1))/(10.0 * (float)(*(CONDNV+ti1))),*(CONDNV+ti1));
						if(strlen(SysSubfileName) > 2)
							fprintf(SysSubfile,"%7.1f",(float)(*(CONDV+ti1))/(10.0 * (float)(*(CONDNV+ti1))));
						if(debug==3)
							printf("\nSAVING IN Subfile: cond %d seg %d CONDV %ld CONDNV %d DATUM %ld",jc+1,k+1,*(CONDV+ti1),*(CONDNV+ti1),*(CONDV+ti1)/(long)(*(CONDNV+ti1)));
						} /* end    if(mspc || (anal == 9 && poke_anal >= 2 && k != 3))  */
					else
						{ /* anything but if(mspc || (anal == 9 && poke_anal >= 2 && k != 3)) */
						if(strlen(SubfileName) > 2)
							fprintf(Subfile,"%6ld%4d",*(CONDV+ti1)/(long)(*(CONDNV+ti1)),*(CONDNV+ti1));
						if(strlen(SysSubfileName) > 2)
							fprintf(SysSubfile,"%6ld",*(CONDV+ti1)/(long)(*(CONDNV+ti1)));
  					if(debug==3)
							printf("\nSAVING IN Subfile: cond %d seg %d CONDV %ld CONDNV %d DATUM %ld",jc+1,k+1,*(CONDV+ti1),*(CONDNV+ti1),*(CONDV+ti1)/(long)(*(CONDNV+ti1)));
						} /* end anything but if(mspc || (anal == 9 && poke_anal >= 2 && k != 3)) */
					}  /* end if (*CONDNV+ti1)) */
				else
					{  /* not * (CONDNV+til)) */
					if(mspc || (anal == 9 && poke_anal >= 2 && k != 3))
						{
						if(strlen(SubfileName) > 2)
							fprintf(Subfile,"%7.1f%3d",0.0,0);
						if(strlen(SysSubfileName) > 2)
							fprintf(SysSubfile,"%7.1f",0.0);
						if(debug==3)
							printf("\nSAVING ZEROS IN Subfile: cond %d seg %d CONDV %ld CONDNV %d",jc+1,k+1,*(CONDV+ti1),*(CONDNV+ti1));
						}
					else if(anal == 11)
						{
						if(strlen(SubfileName) > 2)
							fprintf(Subfile,"%6d%4d",-1,0);
						if(strlen(SysSubfileName) > 2)
							fprintf(SysSubfile,"%6d",-1);
						if(debug==3)
							printf("\nSAVING -1'S IN Subfile: cond %d seg %d CONDV %ld CONDNV %d",jc+1,k+1,*(CONDV+ti1),*(CONDNV+ti1));
						}
					else
						{
						if(strlen(SubfileName) > 2)
							fprintf(Subfile,"%6d%4d",0,0);
						if(strlen(SysSubfileName) > 2)
							fprintf(SysSubfile,"%6d",0);
					if(debug==3)
						printf("\nSAVING ZEROS IN Subfile: cond %d seg %d CONDV %ld CONDNV %d",jc+1,k+1,*(CONDV+ti1),*(CONDNV+ti1));
						}
					} /* end if not * (CONDNV+til)) */
				} /* end        for(k = begin_print; k < end_print; k++) */
			if(strlen(SubfileName) > 2)
				fprintf(Subfile,"\n");
			} /* end        for(j=0,jc=ncmin-1;jc<ncmax;j++,jc++) */
		if(strlen(SysSubfileName) > 2)
			fprintf(SysSubfile,"\n");
		}
	for(j=0,jc=ncmin-1;jc<ncmax;j++,jc++)
		for(k=0;k<nregmax;k++)
			{
			ti1 = k*nctot + j;
			if(*(CONDNV + ti1) != 0)
				{
				*(CUMCV + ti1)+=(*(CONDV+ti1)/(long)(*(CONDNV+ti1)));
				(*(CUMCNV+ti1))++;
				}
/* kludge to get unweighted averages */
				*(CUMCVT + ti1)+=(*(CONDV+ti1));
				(*(CUMCNVT+ti1))+=(*(CONDNV+ti1));

			if(debug == 3)
				printf("\n  cond=%d seg=%d CONDV=%ld CONDNV=%d CUMCV=%ld CUMCNV=%d",jc+1,k+1,*(CONDV+ti1),*(CONDNV+ti1),*(CUMCV+ti1),*(CUMCNV+ti1));
			}/* end   for(k=0;k<nregmax;k++)  */
	}  /*end   not anals 12 or 15  or 17 or 18 or 19*/
else if(anal == 12 && strlen(SubfileName) > 2)			/* analysis 12, position as function of time */
	{
	for(j=0,jc=ncmin-1;jc<ncmax;j++,jc++)
		{
/*pft kludge 
for(sample=0;sample<cum_positions;sample++)
	{
	ti1 = sample*nctot + j;
	printf("\ninitial ti1 %d COUNT_TOTAL_CUMPOS = %d COUNT_CUMPOS %d CUMPOS %d",ti1,*(COUNT_TOTAL_CUMPOS+ti1),*(COUNT_CUMPOS+ti1),*(CUMPOS+ti1));
	}
if(getchar() == 'q')
	exit(1);*/

		pos_collapsecond(j,jc,nimin,nimax,nscmax,nitot,nctot);
		fprintf(Subfile,"%5d%5d",i+1,jc+1);	/* subject and condition number */
		for(sample=0;sample<cum_positions;sample++)
			{
			ti1 = sample*nctot + j;
			if((*(COUNT_CUMPOS+ti1)) && (*(CUMPOS+ti1) > -800))
				*(CUMPOS+ti1) = ((*(CUMPOS+ti1))*10)/(*(COUNT_CUMPOS+ti1));
			else if(sample > 0)
				*(CUMPOS+ti1) = -998;
			fprintf(Subfile,"%8.2f",(float)(*(CUMPOS+ti1))/10.0);
			if(*(CUMPOS + ti1) > -800)
				{
				*(TOTAL_CUMPOS+ti1) += (float)(*(CUMPOS+ti1))/10.0;
				(*(COUNT_TOTAL_CUMPOS+ti1))++;
				}
			}  /* end               for(sample=0;sample<cum_positions;sample++) */

		fprintf(Subfile,"\n");
		}  /* end for(j=0,jc=ncmin-1;jc<ncmax;j++,jc++) */
	} /* end of analysis 12; add more here? */
else if(anal == 15 && strlen(SubfileName) > 2)	/* matrix analysis */
	{
	for(j=0,jc=ncmin-1;jc<ncmax;j++,jc++)
		{
		fprintf(Subfile,"%5d%5d\n",i+1,jc+1);	/* subject and condition number */
		for(k=0;k<nregmax;k++)	/* FROM region */
			{
			for(l=0;l<nregmax;l++)	/* TO region */
				{
				ti1 = k*nregmax*nctot + l*nctot + j;
				fprintf(Subfile,"%4d",(*(S_MATRIX+ti1)));
				}
			fprintf(Subfile,"\n");
			}  /* end  for(k=0;k<nregmax;k++) */
		} /* end  for(j=0,jc=ncmin-1;jc<ncmax;j++,jc++) */
	}               /* end of analysis 15 */
else if(anal == 17 && strlen(SubfileName) > 2)	/* matrix analysis */
	{
	for(j=0,jc=ncmin-1;jc<ncmax;j++,jc++)
		{
		fprintf(Subfile,"%5d%5d  ",i+1,jc+1);	/* subject and condition number */
		for(k=0;k<5;k++)	/* word length 4, 5, 6, 7, 8 */
			{
			LandlaunchTotalAll = 0;
			for(l=1;l<8;l++)
				{
				ti1 = j*6*8 + k*8 + l;
				LandlaunchTotalAll += (*(S_MATRIX+ti1));
				}				
			for(l=1;l<8;l++)	/* landing position, from first letter on */
				{
				ti1 = j*6*8 + k*8 + l;
				if(LandlaunchTotalAll == 0)
					fprintf(Subfile,"    0");
				else
					fprintf(Subfile,"%5d",((*(S_MATRIX+ti1))*100)/LandlaunchTotalAll);
				}
			}  /* end  for(k=0;k<nregmax;k++) */
		} /* end  for(j=0,jc=ncmin-1;jc<ncmax;j++,jc++) */
	fprintf(Subfile,"\n");
	}               /* end of analysis 17 */

	if(debug != 0)
		printf("\nEnd of subject %d\n",i+1);
	}       /* end of subject loop */


fprintf(printer,"\n\n***** OUTPUT *****\n%s\n*****\n",string);
if(anal == 1)
	{
	if(poke_anal == 1)
		fprintf(printer,"\nFirst fixation");
	else if(poke_anal == 2)
		fprintf(printer,"\nSingle fixation on region");
	else if(poke_anal == 3)
		fprintf(printer,"\nFirst of multiple fixations");
	else if(poke_anal == 4)
		fprintf(printer,"\nSecond of two or more fixations");
	else if(poke_anal == 5)
		fprintf(printer,"\nFixation just before first in region");
	}
else if(anal == 2)
		{
    fprintf(printer,"\nFirst pass time (gaze duration if one-word regions)");
		fprintf(printer,"\nUpper cutoff for gaze duration %d",fpcutoff);
		}
else if(anal == 3)
	{
	fprintf(printer,"\nTotal time: Upper cutoff for cumulated total time duration %d\n",ttcutoff);
	fprintf(printer,"\nIndividual fixations eliminated with long time %d, short time %d",longtime,shorttime);
	if(nsub>0)
		{
		fprintf(printer,"\nProportion of long times %f",sum_prop_long/(float)nsub);
		fprintf(printer,"\nProportion of short times %f\n",sum_prop_short/(float)nsub);
		}
	}
else if(anal == 4)	/* oreg */
	fprintf(printer,"\nPercentage of trials where one or more legal first pass fixations in region\nwere followed by a legal fixation to earlier point in the sentence.");
else if(anal == 5)	/* ireg */
	fprintf(printer,"\nPercentage of trials where one or more legal fixations in region were preceded\nby legal fixation in a later region of the sentence.");
else if(anal == 6)	/* prob first fix */
	{
	if(poke_anal == 1)
		fprintf(printer,"\nPercentage of trials on which a nonregressive fixation was madein a region\n");
	else if(poke_anal == 2)
		fprintf(printer,"\n% trials on which there was exactly one nonregressive fixation in a region\n");		
	else if(poke_anal == 3)
		fprintf(printer,"\nMean duration of last fixation in prior region prior to skip region n\n");
	else if(poke_anal == 4)
		fprintf(printer,"\nMean duration of first fixation in following region after skip region n\n");
	else if(poke_anal == 5)
		fprintf(printer,"\nMean duration of last fixation in prior region before landing in region n\n");
	else if(poke_anal == 6)
		fprintf(printer,"\nMean duration of first fixation in following region after landing in region n\n");
	if(poke_anal >= 3)
		fprintf(printer,"Region n is column number n\nFixations prior to skip of or landing in last region not reported\n");

	}
else if(anal == 7)  /* number of fixations in region */
	{
  fprintf(printer,"\nNumber of fixations in region.");
  if(poke_anal == 1)
  	fprintf(printer,"  Only fixations before leaving region counted.");
  else
  	fprintf(printer,"  All fixations in region counted.");
	}
else if(anal == 8)  /* sec pass */
	{
	if(throwaway_zero == 0)
		fprintf(printer,"\nSecond pass: Treating non-regressions as zero durations in means.");
	else
		fprintf(printer,"\nSecond pass: Discarding zero duration trials in means.");
	if(poke_anal == 1)
		fprintf(printer,"\nIncluding only rereading time after gone past region.");
	else if(poke_anal == 2)
		fprintf(printer,"\nIncluding rereading time after leave region to L or to R.");
	else
		fprintf(printer,"\nIncluding rereading time after leave region to left.");
	}
else if(anal == 9)
	{
	fprintf(printer,"\nEyepoke (target fixation plus 3 previous, 3 following)");
	fprintf(printer,"\n  ignoring short fixations, deleting all fixations after\n  long or out of bounds fixation.");
	if(poke_anal == 2)
		fprintf(printer,"\n  mean signed value of all saccade lengths, counting from target fixation.");
	else if(poke_anal == 3)
		fprintf(printer,"\n  mean length of saccades before a regression, counting from target fix.");
    else if(poke_anal == 4)
        fprintf(printer,"\n  proportion of forward saccades.");
	}
else if(anal == 10)
	fprintf(printer,"\nEyegaze (single region of interest, moving boundary left)");
else if(anal == 16)
	fprintf(printer,"\nTotalgaze (total time in single region of interest, moving boundary left\njust in case eyegaze moved it left)");
else if(anal == 11)
	{
	if(poke_anal == 1)
		fprintf(printer,"\nMean landing position (chars into region, 0 = first char or space");
	else if(poke_anal == 3)
		fprintf(printer,"\nMean launch site, chars before start of region");
	else
		fprintf(printer,"\nMean landing position of second fixation in region");
	}
else if(anal == 12)
	{
	fprintf(printer,"\nDisk file output only for now; position as function of time.");
	fprintf(printer,"\nGrain size = %d ms (sampling interval)",cum_grain);
	}
else if(anal == 13)
	{
	fprintf(printer,"\nTime from entering region to first going past it (quasi-first-pass time).");
	if(poke_anal == 1)
		fprintf(printer,"\n  Sum of ALL time since entering, including time outside region.");
	else if(poke_anal == 2)
		fprintf(printer,"\n  Just the time spent IN the region after first entering it.");	
	else
		fprintf(printer,"\n Sum of time spent OUTSIDE region from first entering to first going past.");
	}
else if(anal == 14)
	{
	fprintf(printer,"\nFirst fixation AFTER leaving critical region.");
	if(poke_anal%2)
		fprintf(printer,"\n  Last fixation in sentence eliminated.");
	else
		fprintf(printer,"\n  Last fixation in sentence kept.");
	if((poke_anal/2)%2)
		fprintf(printer,"\n  Reporting length of first saccade out of region.");
	else
		fprintf(printer,"\n  Reporting duration of first fixation out of region.");
	if((poke_anal/4)%2)
		fprintf(printer,"\n  Reporting both forward and regressive saccades from region\n(absolute value of length).");
	else
		fprintf(printer,"\n  Reporting only forward saccades from region.");
	if((poke_anal/8)%2)
		fprintf(printer,"\n  Reporting spillover after 1 or more fixations in region.");
	else
		fprintf(printer,"\n  Reporting spillover after exactly 1 fixation in region.");
	}
else if(anal == 15)
	{
	fprintf(printer,"\nMatrix of eye movements, from region to region.\n");
	if(which_matrix == 1)
		fprintf(printer,"\n   type 1: all saccades\n");
	else if(which_matrix == 2)
		fprintf(printer,"\n   type 2: only leading edge saccades (not after regression)");
	}
else if(anal == 17)
	{
	fprintf(printer,"\nNumbers of first fixations in words, word length x position.\nCritical region = %d, last row is LAUNCH POSITION\n",which_reg+1);
	if(StartPrevFix != 0)
		fprintf(printer,"\nOnly landings where lauch was between %d and %d letters before region",StartPrevFix,EndPrevFix);
	for(i = 0; i < nctot; i++)
		{
		LandlaunchTotalAll = 0;
		fprintf(printer,"\n\nCOND %d\n",i+ncmin);
		for(j = 0; j < 6; j++)
			{
			LandlaunchTotal[j] = 0;
			for(k = 0; k< 8; k++)
				{
				if(k != 0)
					LandlaunchTotal[j] += *(CUM_MATRIX + i*8*6 + j*8 + k);		/* don't count land in position before word in calculating percentages */
				if(j < 5)
					LandlaunchTotalAll += *(CUM_MATRIX + i*8*6 + j*8 + k);
				if(j == 0 && k == 0)
					fprintf(printer,"\nLENGTH   POS 0 POS 1 POS 2 POS 3 POS 4 POS 5 POS 6 POS 7 TOTAL (not 0 landings)\n  %3d  ",j+4);
				fprintf(printer,"%6d",*(CUM_MATRIX + i*8*6 + j*8 + k));
				if(k == 7)
					{
					if(j < 5)
						fprintf(printer,"%6d",LandlaunchTotal[j]);
					else
						fprintf(printer,"%6d",LandlaunchTotalAll);
					if(j < 4)
						fprintf(printer,"\n  %3d  ",j+5);
					else if(j == 4)
						fprintf(printer,"\n launch  POS 1 POS 2 POS 3 POS 4 POS 5 POS 6 POS 7 POS 8 TOTAL(incl 0 landing)\n       ");
					}
				}
			}
	/* now print out percentages */
		fprintf(printer,"\n\nPERCENTAGES");
		for(j = 0; j < 6; j++)
				{
				for(k = 0; k< 8; k++)
					{
					if(j == 0 && k == 0)
						fprintf(printer,"\nLENGTH   POS 0 POS 1 POS 2 POS 3 POS 4 POS 5 POS 6 POS 7 TOTAL (not 0 landings)\n  %3d  ",j+4);
					if(k == 0 && j != 5)
						fprintf(printer,"      ");
					else if(j < 5)
						{
						if(LandlaunchTotal[j] == 0)
							fprintf(printer,"     0");
						else
							fprintf(printer,"%6d",(*(CUM_MATRIX + i*8*6 + j*8 + k)*100)/LandlaunchTotal[j]);
						}
					else
						{
						if(LandlaunchTotalAll == 0)
							fprintf(printer,"     0");
						else
							fprintf(printer,"%6d",(*(CUM_MATRIX + i*8*6 + j*8 + k)*100)/LandlaunchTotalAll);				
						}
					if(k == 7)
						{
						if(j < 5)
							fprintf(printer,"%6d",LandlaunchTotal[j]);
						else
							fprintf(printer,"%6d",LandlaunchTotalAll);
						if(j < 4)
							fprintf(printer,"\n  %3d  ",j+5);
						else if(j == 4)
							fprintf(printer,"\n launch  POS 1 POS 2 POS 3 POS 4 POS 5 POS 6 POS 7 POS 8 TOTAL (incl 0)\n       ");
	
						}
					}
				}
			}
/*	fprintf(printer,"\nNumbers of launch sites, by # letters before start of region.\n       ");
	for(j=0;j < 8;j++)
		fprintf(printer,"%6d",LaunchSite[j]);*/
	goto early_end;
	}

if(anal == 20)				/* just lengths */
	fprintf(printer,"Lengths of regions");


if(anal <= 3 || anal == 6 || anal == 11 || anal == 17)
	if(StartPrevFix != 0)
		fprintf(printer,"Prev fix between %d and %d chars before start of region",StartPrevFix,EndPrevFix);

if(throwaway_zero == 0)
	fprintf(printer,"\n\nKEEPING trials with no fixations (count as 0 duration).");
else if(throwaway_zero == 1)
	fprintf(printer,"\n\nTHROWING AWAY trials with no fixations.");
if(anal != 12)
	summarize(nimin,nimax,nscmax,nregmax,ncmin,ncmax,nitot,nctot,poke_anal,anal,around_end);
else if(anal == 12)
	write_position_stuff(ncmin,ncmax,nctot);
if(anal == 15)
	write_matrix(ncmin,ncmax,nctot,nregmax);
early_end:
fprintf(printer,"\f\n");


/* CLEAN UP*/
if(strlen(AllfileName) > 2)
	fclose(Allfile);
if(strlen(SenfileName) > 2)
	fclose(Senfile);
if(strlen(SubfileName) > 2)
	fclose(Subfile);
if(strlen(SysSenfileName) > 2)
	fclose(SysSenfile);
if(strlen(SysSubfileName) > 2)
	fclose(SysSubfile);
rewind(datalst);
if(exceptflag)
	rewind(except);
if(anal == 15 || anal == 17)
	{
	free(S_MATRIX);
	free(CUM_MATRIX);
	free(I_MATRIX);
	}
if(anal == 12)
{
free(COUNT_TOTAL_CUMPOS);
free(COUNT_CUMPOS);
free(TOTAL_CUMPOS);
free(CUMPOS);
free(TCUMPOS);
}
free(ITEMCOND);
free(ITEMSEQ);
if(anal < 18)
{
free(CUMCNVT);
free(CUMCVT);
free(CUMCNV);
free(CUMCV);
free(CONDNV);
free(CONDV);
free(CUMNV);
free(CUMV);
free(NV);
free(V);
}

print_on = 0;			/* turn off data file name printing */
}			/* end of loop for type of analysis */
end:
free(C);
free(NR);
fclose(datalst);
fclose(printer);
fclose(conbuff);
if(exceptflag)
	fclose(except);
} /* END OF MAIN */



/************************************************************************/




/* FUNCTION to get control list into C[item][subcond][region]   */
/* item is real item number */
/* real condition number is stored at region = 0 */

int getcontrol(int nimin,int nitot,int ncmin,int nctot,int nregmax,int nscmax)
{
int region,index,icond;
int nregion;
int item,tempitem,tempcond;
int ni;
char c;
item = 0;
icond = -1;	/* will go to 0 first time around */
printf("\n Control (.CNT) file name? - ");
while((conbuff=fopen(gets(file),"r")) EQ 0)
	printf("\nCan't find control file; try again.\n");
fprintf(printer,"Control (.CNT) file %s\n",file);
ni = 0;
while((c = fgetc(conbuff)) != EOF)	/* count the lines */
	{
/*	printf("%c",c);*/
	if(c == '\n')
		ni++;
	}
fprintf(printer,"control file length %d\n",ni);
rewind(conbuff);
for(index=0;index<ni;index++)
	{
	region = 0;
	if(fgets(buff,MAXLINE,conbuff) EQ NULL)
		{
		printf("\nError reading control file, item %d ",index+1);
		exit(1);
		}
//	if((tempitem = readnext(0)) EQ ERR)	/* get item number */
//		{
//		printf("\nError reading item # in control file, item %d ",index+1);
//		exit(1);
//		}
//	if((tempcond = readnext(1)) EQ ERR)		/* cond # */
//		{
//		printf("\nError reading cond # in control file, item %d ",index+1);
//		exit(1);
//		}

		  tempitem = readnext(0); // replaced code above for gcc
		  tempcond = readnext(1);



	if(tempitem >= nimin && tempitem < (nimin+nitot) && tempcond >= ncmin && tempcond < (ncmin+nctot))	/* skip out sens */
		{
		item = tempitem -nimin;

/*
		if(tempitem-nimin EQ item)
			icond++;
		else
			{
			icond = 0;
			item = tempitem -nimin;
			}
*/
		for(icond = 0; *(C+icond*nitot + item) != 0;)
			icond++; 
		if(icond >= nscmax)
			{
			printf("\nAttempting to store too many subconditions for item %d",tempitem);
			exit(1);
			}
		*(C+icond*nitot + item) = tempcond;	
		if(debug == 3)
			printf("\nRead C: tempcond %d at icond %d item %d",*(C+icond*nitot + item),icond+1,item+1);
		nregion = (*(NR + icond*nitot + item) = readnext(1));	/* number of regions */
		if(nregion > nregmax)
			{
			printf("\nPROBLEMS: %d is more regions that you calloc'd space for",nregion);
			exit(1);
			}
		readnext(1);		/* skip over constant 0 at start */
		if(debug EQ 1)
			printf("\nGETCCONTROL: ITEM %d CONDITION %d",item+1,*(C+icond*nitot+item));	
		for(region = 1; region < nregion; region++)
			{
			*(C+ region*nitot*nscmax + icond*nitot + item) = readnext(1);
			if(debug EQ 1)	/* read in region starts */	
				{
				printf("\n  C[%d][%d][%d] = %d",item,icond,region,*(C+region*nitot*nscmax+icond*nitot+item));
				if(getchar() == 'q')
					exit(1);
				}

			} /* end for(region = 1; region < nregion; region++) */
		} /* end        if(tempitem >= nimin && tempitem < (nimin+nitot) && tempcond >= ncmin && tempcond < (ncmin+nctot))       skip out sens */
	} /* for(index=0;index<ni;index++) */
return(ni);
} /*END GET CONTROL*/




/* reads next ASCII-coded number from buff[] */
/* starts at beginning of buff[] if control = 0 */
int readnext(int control)
{
static int bptr;
int value;
if(control EQ 0)
	bptr = 0;
while (!isdigit(*(buff+bptr)))
	bptr++;
value = atoi(buff+bptr);
while(isdigit(*(buff+bptr++)))
	;
if(debug EQ 1)
	printf("\nIn readnext: value = %d, bptr = %d, control = %d",value,bptr,control);
return(value);
}


/* FUNCTION FOR READING INDIVIDUAL SUBJECT DATA, SORTING INTO
V[item][subcondition][region] */
int sortsubject(int i,int nimin,int nimax,int ncmin,int ncmax,int nscmax,int qskip,int cpos,int ipos,int npos,int dpos,int longtime,int shorttime,int lookahead,int minq,int maxq,int qcpos,int qresppos,int nitot,int poke_anal,int cum_grain,int nregmax,int nctot,int around_end,int double_space,int StartPrevFix,int EndPrevFix,int trigger_region,int trigger_region_adjustment)
{
FILE *gdbuff;
int number_fixations;
int fpt,lpt;
int endsen,region,sptrptr, cptrptr, icond, ns;
int seqptrptr;
int temppos,temptime,temps,tempe,tempx,tempy;
int otemptime;
int qcond,qresp;
int start_record;
int nregion,fixation;
int start_region,end_region,region_length;
int nextpos,nexttime;
char *ttbuff;					/* temporary storage for data start */
int past_region, in_region;
int base_region,temp_start_region,ik,moved_right;
int got_cond_reg;
int got_cond_fix;
int ils;
double ftemptime;  
int lastx,lasty;			/* for inh ret screen */
int toomanyregressions, successiveregressions;
int GotFix;
int start_trigger_region, end_trigger_region;

fscanf(datalst,"%s",file);
if(print_on || chatter)
	fprintf(printer,"\nS# %d, ****%s****",i+1,file);
else
	fprintf(printer,"\n S# %d",i+1);
if((gdbuff=(fopen(file,"r"))) EQ NULL)
	openfail(file);
if(debug EQ 2)
	{
	printf("\n\nIN SORTSUBJECT, i = %d nimax = %d nscmax = %d gdbuff = %d",i,nimax,nscmax,gdbuff);
	if(getchar() == 'q')
		exit(1);
	}
if(i == 0 && anal == 18)			/* first S, inh reg function */
	fprintf(Subfile,"subj item cond otype launchr launchp launchd landr landp landd saclength prevdur prevsaclength chars-off");
/* deviation from reg */
if(mspc == 2 && (anal == 2 || anal == 3 || anal == 10 || anal == 8))
	{   /* fp, tt, gaze or second pass */
	if(first_region_for_regression == 0)
		{
		printf("\nProgram will compute regression parameters if they don't already\nexist in files. It will analyze from where you want to begin\nthrough the next-to-last region of sentences %d through %d",nimin,nimax);
		printf("\n\nWhich region do you want to begin with? (>= 1) ");
		scanf("\n%d",&first_region_for_regression);
		}
	past_region = in_region = FALSE;
	if(get_regression(nimin,nimax,ncmin,ncmax,nscmax,qskip,cpos,ipos,npos,dpos,longtime,shorttime,nitot,i,&past_region, &in_region, poke_anal,around_end,double_space) == 0)
		{               /* error return */
		fclose(gdbuff);
		return(0);
		}
	cleararrays(nitot,nctot,nscmax,nregmax,i);
	past_region = in_region = FALSE;
	} /* end deviation from regression */


if(gazeanal  || anal == 17)   /* eyepoke, eyegaze, cumulate_position */
	base_region = which_reg;
else
	base_region = 0;


while(fgets(buff,MAXLINEX,gdbuff) != NULL)	/* keep going until EOF */
	{
	if(buff[0] == '\n')			/* patch to get rid of dummy items */
		printf("\nWATCH IT -- EXTRA NL");
	else 
	{
	if(last_seq > 0)
		curr_seq = atoi(buff+spacebuff(buff,1)) + 1;
	seqptrptr = atoi(buff+spacebuff(buff,1));		/* read in sequence as first item on line */
	cptrptr = atoi(buff+spacebuff(buff,cpos));
	sptrptr = atoi(buff+spacebuff(buff,ipos));
	if(strlen(buff) >= MAXLINEX)
		{
		printf("\nOVERFLOW WARNING: Item following item %d too long for buffer",sptrptr+1);
		fprintf(printer,"\nOVERFLOW WARNING: Item following item %d too long for buffer",sptrptr+1);
		}
	number_fixations = atoi(buff+spacebuff(buff,npos));
	if(number_fixations > total_samples)
		{
		printf("\nWARNING: %d fixations on trial %d for subject %d",number_fixations,sptrptr,i+1);
		fprintf(printer,"WARNING!!!: %d fixations on trial %d for subject %d\n",number_fixations,sptrptr,i+1);
		}
	ns = sptrptr-nimin;
	if(exceptflag)
		{ /*exceptions file */
		if(vexcept[ns] == 99)
			cptrptr = ncmax+1;              /* discard item */
		else
			cptrptr += vexcept[ns]; /* adjust condition */
		}

	if(debug EQ 2)
		{
		printf("\n\n NEW SENTENCE sen %d, cond %d, no fixations %d, cpos %d ipos %d\npress key to continue, q to quit.",sptrptr,cptrptr,number_fixations,cpos,ipos);
		if(getchar() == 'q')
			exit(1);
		}
				/* skip junk sentence or sentence out of sequence range plus question if needed */

	if(cptrptr < ncmin || cptrptr > ncmax || sptrptr > nimax || sptrptr<nimin || (last_seq > 0 && (curr_seq < first_seq || curr_seq > last_seq)) || (max_in_cond > 0 && number_in_cond[cptrptr-ncmin] >= max_in_cond))
		{
		if(debug EQ 2)
			printf("\nskipping junk or out of range sen # %d, cond # %d, seq # %d",sptrptr,cptrptr,curr_seq);
		if(qskip == 2)		/* questions with same cond number */
			if(fgets(buff,MAXLINEX,gdbuff) == NULL)
				{
				printf("\nEnd of file after item number %d, looking for question",sptrptr);
				fclose(gdbuff);
				return(1);
				}
		} /* end        if(cptrptr < ncmin || cptrptr > ncmax || sptrptr > nimax || sptrptr<nimin) */

	/*major loop*/
	else if (anal != 15 && anal < 18)           /* OK condition number, get data position and data */
		{ /*get data pos and data for any analysis but 15 or 18 or 19*/
		number_in_cond[cptrptr-ncmin]++;
		endsen = atoi(buff+spacebuff(buff,npos));
		tbuff = buff+spacebuff(buff,dpos);
		ttbuff = tbuff;
		if(debug EQ 2)
			{
			printf("\nSPTRPTR = %d",sptrptr);
			printf("\nCPTRPTR = %d",cptrptr);
			printf("\nENDSEN  = %d",endsen);
			}

		/* find match to cond # */
		for(icond=0;icond<nscmax;icond++)	/* find match to cond # */
			{
			ti1 = icond * nitot + ns;
			if(debug >= 2)
					printf("\n  icond %d *(C+ti1) %d cptrptr %d",icond,*(C+ti1),cptrptr);
			if(*(C+ti1) EQ cptrptr)
				break;
			}
		if(debug >= 2)
			{
			printf("\nFound condition match: icond = %d cptrptr = %d ti1 = %d",icond,cptrptr,ti1);
		 	if(getchar() == 'q')
					exit(1);			/*found match to cond # */
			}

		if(icond EQ nscmax)
			{
			printf("\nSCREWUP SEARCHING FOR SUBCOND! sen %d cond %d",sptrptr,cptrptr);
			exit(1);
			}
		if(debug EQ 2)
			printf("\n    NS = %d, adjusted cond = %d",ns,cptrptr);

		/* reject trials where question wrong */
		if(lookahead)
			{
			do
				{
				if (fgets(qbuff,MAXLINEX,gdbuff) == NULL)
					{
					printf("\nPROBLEM finding question, condition %d.",cptrptr);
					exit(1);
					}
				qcond = atoi(qbuff + spacebuff(qbuff,qcpos));
				if(debug == 2)
					printf("\nQCOND = %d",qcond);
				}
			while(qcond < ncmin || (qcond > ncmax && (qcond < minq || qcond > maxq)));

			if(qcond >= ncmin && qcond <= ncmax)
				{
				printf("\nTROUBLES: found real trial before finding question, condition %d",cptrptr);
				exit(1);
				}
			else
				qresp = atoi(qbuff + spacebuff(qbuff,qresppos));
			if(debug == 2)
				printf("\nqcond = %d qresp = %d",qcond, qresp);
			}/* end if lookahead; trials rejected when ques is wrong */


		/* check for regressions, to conditionalize */
		if(cond_reg)
			{
			ti1 = icond*nitot + ns;
			nregion = *(NR+ti1);
			region = which_cond_reg;		/* check for specified region */
			past_region = 0;
			if(debug == 2)
				printf("\n  Examining region %d sentence %d for CONDITIONALIZING on regression",region,ns);
			ti2 = region*nitot*nscmax + icond*nitot + ns;
			if(region == 0)
				start_region = 0;
			else
				start_region = *(C+ti2);
			if(region == nregion-1)		/* last region */
				{
				end_region = start_region + 20;	/* fake */
				if(end_region/width > start_region/width)	/* went around end */
					end_region = (start_region/width) * width + width-1;
								/* set end_region to end of line */
				} /* end if last region */
			else
				{
				end_region = *(C+ti2+nitot*nscmax);
				}

			region_length = end_region - start_region;
			if(!around_end)		/* don't allow regions to wrap around end of line? */
				if(start_region/width < end_region/width || region_length > width)	/* went around end */
					start_region = (end_region/width) * width;	/* start of current line */
			region_length = end_region - start_region;

			if(double_space)
				while(region_length > width)
					region_length -= width;			/* get rid of skipped lines */

			for(fixation=0,start_record=FALSE;fixation < endsen && fixation != -1; fixation++)
				{
				if(debug == 2)
					{
					printf("\n fix %d sen %d",fixation,ns);
						if(getchar() == 'q')
					exit(1);
					}
				tempx = atoi(tbuff);			/* x pos of fix */
				movenextnumber();
				tempy = atoi(tbuff);			/* y pos of fix */
				movenextnumber();
				temps = atoi(tbuff);			/* start fix time */
				movenextnumber();
				tempe = atoi(tbuff);			/* end fix time */
				movenextnumber();
				temppos = tempx + (tempy-yoffset) * width;	/* fixation position */
				temptime = tempe-temps;
				if(!start_record)	/* skip past any bad initial fixations */
					{				
					if(temppos >= -1 && temppos < end_region)
						{
						start_record = TRUE;
						}
					} /* end if (!start_record)*/
				if(start_record && tempy >= 0 && tempy < max_y) /* discard fixations with negative */
					{                                       /* or oversized y values as well as bad initial fix */
					if(debug == 2)
						printf("\n\nSCANNING FOR REGS:fix %d start_reg %d, end_reg %d temppos %d\n tempx %d tempy %d temps %d tempe %d",fixation,start_region,end_region,temppos, tempx,tempy,temps,tempe);
					fixation = check_reg(fixation,temppos,temptime,endsen,start_region,end_region,shorttime,longtime,region,ns);
					if(fixation == -1)
						fixation = -2;		/* ugly eh? */
					}
				} /* end for(fixation=0,start_record=FALSE;fixation < endsen && fixation != -1; fixation++) */
			if((fixation == -1 && cond_reg == 1) || (fixation >= endsen && cond_reg == 2))
				got_cond_reg = 1;		/* wanted and got regression, or ditto nonregression */
			else
				got_cond_reg = 0;
			if(debug == 2)
				printf("\n   got_cond_reg = %d sentence %d",got_cond_reg, ns);
			}

/*end if cond_reg, have checked for regressions so can conditionalize */

		/* check for fixations, to conditionalize */
		if(cond_fix)		/* 0 = don't conditionalize, 1 = keep, 2 = eliminate */
			{
			ti1 = icond*nitot + ns;
			nregion = *(NR+ti1);
			region = which_cond_fix;		/* check for specified region */
			past_region = 0;
			if(debug == 2)
				printf("\n  Examining region %d sentence %d for CONDITIONALIZING on fixation",region,ns);
			ti2 = region*nitot*nscmax + icond*nitot + ns;
			if(region == 0)
				start_region = 0;
			else
				start_region = *(C+ti2);
			if(region == nregion-1)		/* last region */
				{
				end_region = start_region + 20;	/* fake */
				if(end_region/width > start_region/width)	/* went around end */
					end_region = (start_region/width) * width + width-1;
								/* set end_region to end of line */
				} /* end if last region */
			else
				{
				end_region = *(C+ti2+nitot*nscmax);
				}

			region_length = end_region - start_region;
			if(!around_end)		/* don't allow regions to wrap around end of line? */
				if(start_region/width < end_region/width || region_length > width)	/* went around end */
					start_region = (end_region/width) * width;	/* start of current line */
			region_length = end_region - start_region;

			if(double_space)
				while(region_length > width)
					region_length -= width;			/* get rid of skipped lines */

			for(fixation=0,start_record=FALSE;fixation < endsen && fixation != -1; fixation++)
				{
				if(debug == 2)
					{
					printf("\n fix %d sen %d",fixation,ns);
						if(getchar() == 'q')
					exit(1);
					}
				tempx = atoi(tbuff);			/* x pos of fix */
				movenextnumber();
				tempy = atoi(tbuff);			/* y pos of fix */
				movenextnumber();
				temps = atoi(tbuff);			/* start fix time */
				movenextnumber();
				tempe = atoi(tbuff);			/* end fix time */
				movenextnumber();
				temppos = tempx + (tempy-yoffset) * width;	/* fixation position */
				temptime = tempe-temps;
				if(!start_record)	/* skip past any bad initial fixations */
					{				
					if(temppos >= -1 && temppos < end_region)
						{
						start_record = TRUE;
						}
					} /* end if (!start_record)*/
				if(start_record && tempy >= 0 && tempy < max_y) /* discard fixations with negative */
					{                                       /* or oversized y values as well as bad initial fix */
					if(debug == 2)
						printf("\n\nSCANNING FOR FIXS:fix %d start_reg %d, end_reg %d temppos %d\n tempx %d tempy %d temps %d tempe %d",fixation,start_region,end_region,temppos, tempx,tempy,temps,tempe);
					fixation = check_fix(fixation,temppos,temptime,endsen,start_region,end_region,shorttime,longtime,region,ns);
					if(fixation == -1)
						fixation = -2;		/* ugly eh? - it's going to add 1,leaving it as -1*/
					}
				} /* end for(fixation=0,start_record=FALSE;fixation < endsen && fixation != -1; fixation++) */
			if((fixation == -1 && cond_fix == 1) || (fixation >= endsen && cond_fix == 2))
				got_cond_fix = 1;		/* wanted and got refix, or ditto nonfix */
			else
				got_cond_fix = 0;
			if(debug == 2)
				printf("\n   got_cond_fix = %d sentence %d",got_cond_fix, ns);
			}

/*end if cond_fix, have checked for fixations so can conditionalize */
	tbuff = ttbuff;         /* restore buffer pointer */
	if((lookahead ==  qresp || lookahead == FALSE) && (cond_reg == 0 || got_cond_reg == 1) && (cond_fix == 0 || got_cond_fix == 1))
			{ /*another major loop */
			ti1 = icond*nitot + ns;
			*(ITEMSEQ+ti1) = seqptrptr;	/* sequence number for this subj, this sent */
			*(ITEMCOND+ti1) = cptrptr; /* cond no for this subj,this sent */
			if(gazeanal)       /* eyepoke, eyegaze */
				nregion = 9999;
			else
				nregion = *(NR+ti1);
	/* kludge for Jane */
			if(anal == 17)
				nregion = 9999;
			if(debug == 2)
				{
				printf("\n\nGoing to region x fixation scan, %d regions",nregion);
				if(getchar() == 'q')
					exit(1);
				}
			moved_right = 0;
			for(ils=0;ils<total_samples+1;ils++)
				longs[ils] = shorts[ils] = 0;		/* zero counts for this sentence */

			/* Tim Slattery kludge, for second pass */
			if(anal == 8)
				{
				ti2 = trigger_region*nitot*nscmax + icond*nitot + ns;
				start_trigger_region = *(C+ti2);
				end_trigger_region = *(C+ti2+nitot*nscmax);
				start_trigger_region -= trigger_region_adjustment;
				}

pokeloop:		/* big loop for eyepoke, eyegaze */
			for(region=base_region,ik = 0,got_fix = 0;region < nregion; region++,ik++)
/* note, this loop is a weird fake for eyepoke and eyegaze and cumulate_position */
				{
				in_region = 0;
				past_region = 0;
				if(debug == 2)
					{
					printf("\n  Examining region %d",region);
					}
				ti2 = region*nitot*nscmax + icond*nitot + ns;
				if(region == 0)
					start_region = 0;
				else
					start_region = *(C+ti2);
				if(region == nregion-1)		/* last region */
					{
					end_region = start_region + 20;	/* fake */
					if(end_region/width > start_region/width)	/* went around end */
						end_region = (start_region/width) * width + width-1;
									/* set end_region to end of line */
					}
				else
					{
					end_region = *(C+ti2+nitot*nscmax);
		      if(gazeanal)   /* eyepoke, eyegaze */
						end_region += moved_right;		/* move right one */
					}

				region_length = end_region - start_region;
				if(!around_end)		/* don't allow regions to wrap around end of line? */
					if(start_region/width < end_region/width || region_length > width)	/* went around end */
						start_region = (end_region/width) * width;	/* start of current line */
				region_length = end_region - start_region;
				if(double_space)
					while(region_length > width)
						region_length -= width;			/* get rid of skipped lines */
				if(debug == 2)
					{
					printf("\nRegion length = %d",region_length);
					}

				tbuff = ttbuff;				/* set or reset buffpointer */
				if(gazeanal)       /* eyepoke or eyegaze */
					{
					temp_start_region = start_region - ik;
					}
				for(fixation=0,temp_fixation=0,start_record=FALSE,got_fix = 0;fixation < endsen; fixation++)
					{
					if(debug == 2)
						printf("\nfix %d",fixation);
					tempx = atoi(tbuff);			/* x pos of fix */
					movenextnumber();
					tempy = atoi(tbuff);			/* y pos of fix */
					movenextnumber();
					temps = atoi(tbuff);			/* start fix time */
					movenextnumber();
					tempe = atoi(tbuff);			/* end fix time */
					movenextnumber();
					temppos = tempx + (tempy-yoffset) * width;	/* fixation position */
					temptime = tempe-temps;
					if(!start_record)	/* skip past any bad initial fixations */
						{				
						if(temppos >= -1)
							{
							start_record = TRUE;
							}
						} /* end if (!start_record)*/
				if(start_record && tempy >= 0 && tempy < max_y) /* discard fixations with negative */
					{                                       /* or oversized y values as well as bad initial fix */
					if(debug == 2)
						{
						printf("\n\nBAD fixation %d start_region %d, end_region %d temppos %d\n   tempx %d tempy %d temps %d tempe %d\nPress q to quit: ",fixation,start_region,end_region,temppos, tempx,tempy,temps,tempe);
						if(getchar() == 'q')
							exit(1);
						}

					/*call correct analysis */
					if(anal == 1)
						fixation = ff(fixation,temppos,temptime,endsen,start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,region_length,poke_anal,StartPrevFix,EndPrevFix);
							/* call to first fixation etc. routine */
					else if(anal == 3)
						fixation = tt(fixation,temppos,temptime,start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,region_length,StartPrevFix,EndPrevFix,endsen);
					else if(anal == 2)
						fixation = fp(fixation,temppos,temptime,endsen,start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,region_length,StartPrevFix,EndPrevFix);
					else if(anal == 4)
						{
						if(fixation < endsen - 1)
							fixation = oreg(fixation,temppos,temptime,endsen,start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns);
						}
					else if(anal == 5)
						{
						if(fixation > 0)
							fixation = ireg(fixation,temppos,temptime,endsen,start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns);
						}
					else if(anal == 6)
						fixation = p_init_fix(fixation,temppos,temptime,endsen,start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,poke_anal,StartPrevFix,EndPrevFix,nregion);
					else if(anal == 7)
						fixation = no_fixes(fixation,temppos,temptime,endsen,start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,poke_anal);
					else if(anal == 8)
						fixation = sec_pass(fixation,temppos,temptime,start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,&past_region,&in_region,poke_anal,region_length,endsen,start_trigger_region,end_trigger_region);
					else if(anal == 9)  /* eyepoke */
						fixation = fixes(fixation,temppos,temptime,endsen,temp_start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,nitot,nscmax,icond,poke_anal,ik,region_length);
					else if(anal == 10)  /* eyegaze */
						fixation = gd_fixes(fixation,temppos,temptime,endsen,temp_start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,nitot,nscmax,icond,ik,region_length);
					else if(anal == 11)	/* position*/
						fixation = land_pos(fixation,temppos,temptime,endsen,start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,poke_anal,StartPrevFix,EndPrevFix);
					else if(anal == 12)	/* cumulative position) */
						fixation = cumulate_position(fixation,temppos,temptime,endsen,temp_start_region,end_region,shorttime,longtime,cptrptr,sptrptr,ns,nitot,icond,nscmax,temps,tempy,cum_grain,poke_anal);
					else if(anal == 13)	/* time before going past region */
						fixation = go_past(fixation,temppos,temptime,endsen,start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,poke_anal,region_length);
					else if(anal == 14) /* spillover */
						fixation = next_fix(fixation,temppos,temptime,endsen,temp_start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,nitot,nscmax,icond,ik,poke_anal,region_length);
					else if(anal == 16)  /* totalgaze */
						fixation = total_fixes(fixation,temppos,temptime,endsen,temp_start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,nitot,nscmax,icond,ik,region_length);
					else if(anal == 17)		/* landing & launch */
						fixation = landlaunch(fixation,temppos,temptime,endsen,start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,region_length,ncmin,nimin,nscmax,StartPrevFix,EndPrevFix);
					else  /*not in this loop if anal == 16 so must be invalid analysis */
						{
						printf("\nTHAT'S NO WAY TO ANALYZE YOUR DATA!");
						exit(1);
						}
					} /* end  if(start_record && tempy >= 0 && tempy < max_y)
						fixations with neg or oversized y values and bad initial fixes discarded*/

					else if(debug == 2)
						{
						printf("\nReject fixation %d: start_record = %d, tempy = %d\npress q to quit: ",fixation,start_record,tempy);
/*						if(getchar() == 'q')
							exit(1);*/
						}
					} /* end of  for(fixation... */

				if(gazeanal)       /* eyepoke, eyegaze, totalgaze */
					{
					if(got_fix != 0 || !((start_region-(ik-1))%width) || ik >= move_limit)
						region = nregion;		/* abort for(region... loop */
					else
						region = base_region-1;	/* it will be incremented in loop */
					}/*end if gazeanal*/
				if(anal == 17)
					region = nregion;
				if(mspc == 2)
					{ /*deviations from regressions*/
					/*otemptime = *(V+ti2);*/
/*printf("\ntime %d pred time %f alpha %f beta %f size %d",*(V+ti2),(alpha+beta*(double)(end_region-start_region)),alpha,beta,(end_region-start_region));*/
 				ftemptime = (double)(*(V+ti2)) - (alpha + beta*(double)(region_length));
	 			*(V+ti2) = (int)(ftemptime * 10);
/*printf("\nregion %d otemptime %d, ftemptime %f, start_region %d, end_region %d",region,otemptime,ftemptime,start_region,end_region);*/
					}/*end if deviations from regressions*/

				}  /* matched with for region... */


				if(gazeanal)       /* eyepoke, eyegaze, cumulate_position */
					{
					if(!got_fix && !moved_right)	/* quit if got fix or already moved right */
						{
						moved_right = 1;
						goto pokeloop;			/* sorry, had to do it, to fake loop */
						}
					else
						{ /* not true that (!got_fix && !moved_right) */
						if(got_fix == 2)		/* panic; long time in region */
							{
							if(chatter)
								fprintf(printer,"\nDiscard trial: Cnd %d Itm %d Fix %d Pos %d Time %d Reg from %d to %d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);
							}
						else if(got_fix == 1)
							{
							if(chatter && ik > 1)
								fprintf(printer,"\nAdj reg: C 3%d I %3d Fix %3d Pos %3d Time %5d Reg %4d - %4d chars moved %d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region,ik-1);
							}
						else
							{  /* not true that (!got_fix && !moved_right)
								and not true that (got_fix == 1)*/
							if(chatter && ik > 1)
								fprintf(printer,"\nNo fix in adj reg: cond %3d item %3d chars moved %3d",cptrptr,sptrptr,ik);
							if(keep_to_right)
								{
								if(fixation <= endsen+1)
									{
									if(chatter)
										fprintf(printer,"\nCAREFUL: no data on cnd %d itm %d fix %d endsn %d chars moved %d",cptrptr,sptrptr,fixation,endsen,ik);
									}
								else
									{
									fixation = following_fixes(fixation-endsen,temppos,temptime,endsen,temp_start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,nitot,nscmax,icond,poke_anal,region_length);
									}
								} /*end         if(keep_to_right) */
							} /*end  not true that (!got_fix && !moved_right) and not true that (got_fix == 1)*/
						} /*end not true that (!got_fix && !moved_right) */
					} /* end if gazeanal */

			if(qskip == 2)          /* question on next line, same cond # */
				if(fgets(buff,MAXLINEX,gdbuff) == NULL)
					{
					printf("\nEnd of file after item number %d, looking for question",sptrptr);
					fclose(gdbuff);
					return(1);
					}
					/* count long and short counts */
				for(ils=0;ils<total_samples+1;ils++)
					{
					if(longs[ils] != 0)
						longcount++;
					if(shorts[ils] != 0)
						shortcount++;
					}
				total_fixation_count+=endsen;			/* count total fixations, for total time */

			} /*end if((lookahead==qresp||lookahead==FALSE)&&(cond_reg==0||got_cond_reg==1))*/
		} /* end else if anal != 15 and != 18 */
	else if (anal == 15 || anal == 18)		/* order fix by fix rather than reg by reg */
		{
		endsen = atoi(buff+spacebuff(buff,npos));
		tbuff = buff+spacebuff(buff,dpos);
		ttbuff = tbuff;
		if(debug EQ 2)
			{
			printf("\nanal 18: SPTRPTR = %d",sptrptr);
			printf(" CPTRPTR = %d",cptrptr);
			printf(" ENDSEN  = %d",endsen);
			}
		for(icond=0;icond<nscmax;icond++)	/* find match to cond # */
			{
			ti1 = icond * nitot + ns;
			if(debug >= 2)
				printf("\n  icond %d *(C+ti1) %d cptrptr %d",icond,*(C+ti1),cptrptr);
			if(*(C+ti1) EQ cptrptr)
				break;
			}
		if(debug >= 2)
			printf("\nFound condition match in anal 18: icond = %d cptrptr = %d ti1 = %d",icond,cptrptr,ti1);
		if(icond EQ nscmax)
			{
			printf("\nSCREWUP SEARCHING FOR SUBCOND IN ANAL 18! sen %d cond %d",sptrptr,cptrptr);
			exit(1);
			}
		if(debug EQ 2)
			printf("\n  anal 18: NS = %d, adjusted cond = %d",ns,cptrptr);

		if(lookahead)           /* reject trials where question wrong */
			{
			do
				{
				if (fgets(qbuff,MAXLINEX,gdbuff) == NULL)
					{
					printf("\nPROBLEM finding question, condition %d.",cptrptr);
					exit(1);
					}
				qcond = atoi(qbuff + spacebuff(qbuff,qcpos));
			if(debug == 2)
				printf("\nQCOND = %d",qcond);
				}
			while(qcond < ncmin || (qcond > ncmax && (qcond < minq || qcond > maxq)));
			if(qcond >= ncmin && qcond <= ncmax)
				{
				printf("\nTROUBLES: found real trial before finding question, condition %d",cptrptr);
				exit(1);
				}
			else
				qresp = atoi(qbuff + spacebuff(qbuff,qresppos));
			if(debug == 2)
				printf("\nIn lookahead: qcond = %d qresp = %d",qcond, qresp);
			}/* end if (lookahead)*/

		if(lookahead ==  qresp || lookahead == FALSE)
			{
			ti1 = icond*nitot + ns;
			*(ITEMCOND+ti1) = cptrptr; /* cond no for this subj,this sent */
         if(gazeanal)       /* eyepoke, eyegaze */
				nregion = 9999;
			else
				nregion = *(NR+ti1);
/* weird kludge for inhibition of return code, check for > n regressions && no successive regressions */
				for(fixation=0,temp_fixation=0,toomanyregressions=FALSE,successiveregressions = FALSE,tempx = 0,tempy = 0;fixation < endsen; fixation++)
					{
					lastx = tempx;
					lasty = tempy;
					tempx = atoi(tbuff);			/* x pos of fix */
					movenextnumber();
					tempy = atoi(tbuff);			/* y pos of fix */
					movenextnumber();
					temps = atoi(tbuff);			/* start fix time */
					movenextnumber();
					tempe = atoi(tbuff);			/* end fix time */
					movenextnumber();
					if(fixation > 0 && tempx < lastx && tempy <= lasty && anal == 18)
						{
						temp_fixation++;
						if(successiveregressions == FALSE)
							successiveregressions = TRUE;
						else
							temp_fixation = maxregressions+1;		/* got 2 succ reg, zap the item */
						if(debug == 2)
							printf("\nRegression on fixation %d",fixation);
						}
					else
						successiveregressions = FALSE;
					if(temp_fixation > maxregressions)
						{
						if(debug == 2)
							printf("\nQuitting, too many regressions (%d) on item %d",temp_fixation,sptrptr);
						fprintf(printer,"\nToo many regressions or 2 successive regressions on item %d",sptrptr);
						toomanyregressions=TRUE;
						fixation = endsen;			/* stop the scan */
						}
					}
				tbuff = ttbuff;			/* restore data pointer */
				if(debug == 2)
					printf("\nended regression check for item %d; toomanyregressions? %d ",sptrptr,toomanyregressions);

			for(fixation=0,start_record=FALSE;fixation < endsen && (anal == 15 || !toomanyregressions); fixation++)
				{
				if(debug == 2)
					printf("\n in anal 15 or 18, fixation number %d",fixation);
				tempx = atoi(tbuff);			/* x pos of fix */
				movenextnumber();
				tempy = atoi(tbuff);			/* y pos of fix */
				movenextnumber();
				temps = atoi(tbuff);			/* start fix time */
				movenextnumber();
				tempe = atoi(tbuff);			/* end fix time */
				movenextnumber();
				temppos = tempx + (tempy-yoffset) * width;	/* fixation position */
				temptime = tempe-temps;
				if(tempy >= 0 && tempy < max_y) /* discard fixations with negative */
					{                                       /* or oversized y values as well as bad initial fix */
					if(debug == 2)
						{
						printf("\nin sortsubject for anal 15, 18: found fixation %d temppos %d\n   tempx %d tempy %d temps %d tempe %d\npress q to quit: ",fixation,temppos, tempx,tempy,temps,tempe);
/*						if(getchar() == 'q')
							exit(1);*/
						}
					if(anal == 15)	/* matrix of movements */
						fixation = fill_matrix(fixation,temppos,temptime,shorttime,longtime,cptrptr,sptrptr,nregion,nregmax,ncmin,nctot,nitot,nscmax,ns,icond,around_end);
					else if(anal == 18)
						{
						if (toomanyregressions)
							{
							if(debug == 2)
								printf("\nEnding fixation loop, too many regressions");
							fixation = endsen;
							}
						else
							{
							if(debug == 2)
								printf("\nGoing to inhreturn() sending fixation %d\n",fixation);
							fixation = inhreturn(i,fixation,temppos,temptime,endsen,shorttime,longtime,cptrptr,sptrptr,ns,ncmin,nscmax,nregion,icond,nitot);
							if(debug == 2)
								printf("\n   returning fixation %d",fixation);
							}
						}
					else
						{
						printf("\nTHAT'S NO WAY TO ANALYZE YOUR DATA!");
						exit(1);
						}
					} /* end if(start_record && tempy >= 0 && tempy < max_y) */
					if(debug == 2)
						{
						printf("\nReject fixation %d:  start_record = %d, tempy = %d\npress q to quit: ",fixation,start_record,tempy);
/*						if(getchar() == 'q')
							exit(1);*/
						}
					}       /* matched with for(fixation... */
				if(debug == 2 && anal == 18 && toomanyregressions)
					printf("\nIn anal 18, reject fixation %d: start_record = %d, tempy = %d",fixation,start_record,tempy);

				} /* end if(lookahead ==  qresp || lookahead == FALSE) */

			if(qskip == 2)		/* question on next line, same cond # */
				if(fgets(buff,MAXLINEX,gdbuff) == NULL)
					{
					printf("\nEnd of file after item number %d, looking for question",sptrptr);
					fclose(gdbuff);
					return(1);
					}
		}													/* end of (anal == 15 or 18) */
	else if(anal == 19)				/* readaloud vector analysis */
		{
		endsen = atoi(buff+spacebuff(buff,npos));
		tbuff = buff+spacebuff(buff,dpos);
		ttbuff = tbuff;
		for(icond=0;icond<nscmax;icond++)	/* find match to cond # */
			{
			ti1 = icond * nitot + ns;
			if(debug >= 2)
				printf("\n  icond %d *(C+ti1) %d cptrptr %d",icond,*(C+ti1),cptrptr);
			if(*(C+ti1) EQ cptrptr)
				break;
			}
		nregion = *(NR+ti1);
		if(sptrptr < 10)		/* to permit easy sorting.... */
			fprintf(Allfile,"%d 0%d %d %d ",i,sptrptr,cptrptr,nregion);
		else
			fprintf(Allfile,"%d %d %d %d ",i,sptrptr,cptrptr,nregion);
/*printf("\nXXXX nregion = %d icond = %d base_region = %d",nregion,icond,base_region);*/
		for(region=base_region,ik = 0,got_fix = 0;region < nregion; region++,ik++)
			{
			in_region = 0;
			past_region = 0;
			GotFix = 0;
			if(debug == 2)
				{
				printf("\n  Examining region %d",region);
				}
			ti2 = region*nitot*nscmax + icond*nitot + ns;
			if(region == 0)
				start_region = 0;
			else
				start_region = *(C+ti2);
			if(region == nregion-1)		/* last region */
				{
				end_region = start_region + 20;	/* fake */
				if(end_region/width > start_region/width)	/* went around end */
					end_region = (start_region/width) * width + width-1;
								/* set end_region to end of line */
				}
			else
				{
				end_region = *(C+ti2+nitot*nscmax);
	      if(gazeanal)   /* eyepoke, eyegaze */
					end_region += moved_right;		/* move right one */
				}
			tbuff = ttbuff;				/* set or reset buffpointer */
			for(fixation=0,temp_fixation=0,start_record=FALSE,got_fix = 0;fixation < endsen; fixation++)
				{
				if(debug == 2)
					printf("\nfix %d",fixation);
				tempx = atoi(tbuff);			/* x pos of fix */
				movenextnumber();
				tempy = atoi(tbuff);			/* y pos of fix */
				movenextnumber();
				temps = atoi(tbuff);			/* start fix time */
				movenextnumber();
				tempe = atoi(tbuff);			/* end fix time */
				movenextnumber();
				temppos = tempx + (tempy-yoffset) * width;	/* fixation position */
				temptime = tempe-temps;
/*printf("\nLoop fixs: reg %d fix %d tempx %d tempy %d temps %d tempe %d end_reg %d",region,fixation,tempx,tempy,temps,tempe,end_region);
if(getchar() == 'q')
	exit(1);*/
				if(debug == 2)
					{
					printf("\nfixation %d start_region %d, end_region %d temppos %d\n   tempx %d tempy %d temps %d tempe %d\nPress q to quit: ",fixation,start_region,end_region,temppos, tempx,tempy,temps,tempe);
					if(getchar() == 'q')
						exit(1);
					}
/* function for analysis 19 */
/*printf("\nGoing to region_vector,region %d fixation %d temppos %d",region,fixation, temppos);*/
				fixation = region_vector(fixation,temppos,temps,tempe,temptime,endsen,start_region,end_region,shorttime,cptrptr,sptrptr,region,ns,ik,&GotFix,poke_anal);
				} /* end of  for(fixation... */
			}  /* matched with for region... */
		fprintf(Allfile,"\n");
		}													/* end of (anal == 19) */

	else  /* not ((lookahead==qresp||lookahead==FALSE)&&(cond_reg==0||got_cond_reg==1))*/
		printf("\nDISCARDING SENTENCE %d",ns);
	}	/* end of patch to stop doubling last itme */
	if(debug == 2)
		printf("\nEnd of this item\n\n");
	}  /* end while not EOF */
fclose(gdbuff);
return(1);
}/*end sortsubject */




/* SET INDIVIDUAL SUBJECT ARRAYS TO ZERO */
void cleararrays(int nitot,int nctot,int nscmax,int nregmax,int subjectnumber)
{
int i,j,k,l;

if(anal < 18)
{
for (i=0;i<nitot;i++)
	for (j=0;j<nscmax;j++)
		for (k=0;k<nregmax;k++)
			{
			ti1 = k*nitot*nscmax + j*nitot + i;
			*(V+ti1)=*(NV+ti1)=0;
			}
for (i=0;i<nctot;i++)
	for(j=0;j<nregmax;j++)
		{
		ti1 = j*nctot + i;
		*(CONDV+ti1)=0l;
		*(CONDNV+ti1)=0;
		}
}
for (i=0;i<nitot;i++)
	for(j=0;j<nscmax;j++)
		{
		ti1 = j*nitot + i;
		*(ITEMCOND+ti1) = 0;
		}
if(anal == 12)
{
for(i=0;i<nctot;i++)
	for(j=0;j<cum_positions;j++)
		{
		ti1 = j*nctot + i;
		*(CUMPOS+ti1) = 0;
		*(COUNT_CUMPOS+ti1) = 0;
		}
}
for(i=0;i<nitot;i++)
	for(j=0;j<nscmax;j++)
		{
		if(anal == 12)
			{
			for(k=0;k<cum_positions;k++)
				{
				ti1=k*nscmax*nitot + j*nitot + i;
				*(TCUMPOS+ti1) = -889;
				}
			}
		if((anal == 15) && subjectnumber == 0)
			for(k=0;k<nregmax;k++)
				for(l=0;l<nregmax;l++)
					{
					ti1=l*nregmax*nscmax*nitot + k*nscmax*nitot + j*nitot + i;
					*(I_MATRIX+ti1) = 0;
					}
		if((anal == 17) && subjectnumber == 0)
			for(k=0;k<6;k++)
				for(l=0;l<8;l++)
					{
					ti1=i*nscmax*6*8 + j*6*8 + k*8 + l;
					*(I_MATRIX+ti1) = 0;
					}

		}
if(anal == 15)
	{
	for(i=0;i<nctot;i++)
		for(j=0;j<nregmax;j++)
			for(k=0;k<nregmax;k++)
					{
					ti1 = k*nregmax*nctot + j*nctot +i;
					*(S_MATRIX+ti1) = 0;
					}
	}
if(anal == 17)
	{
	for(i=0;i<nctot;i++)
		for(j=0;j<6;j++)
			for(k=0;k<8;k++)
					{
					ti1 = i*6*8 + j*8 + k;
						*(S_MATRIX+ti1) = 0;
					}

	}
for(i=0;i<100;i++)
	number_in_cond[i] = 0;
return;
} /*end cleararrays*/



/* COLLAPSE VALUES ACROSS ALL ITEMS IN A CONDITION */
void collapsecond(int ic,int cond,int nimin,int nimax,int nscmax,int nregmax,int nitot,int nctot)
{
int region,icond,ns;

for(ns=0;ns<nimax-nimin+1;ns++)	/* check all item/subcondition combos */
	for(icond=0;icond<nscmax;icond++)
		{
		ti1 = icond * nitot + ns;
		if(*(ITEMCOND+ti1) EQ cond+1)	/* data for this subj,sen,&cond */
			{
			for(region=0;region<nregmax;region++)
				{
				ti2 = region*nitot*nscmax + icond*nitot + ns;
				ti3 = region*nctot + ic;
				if((*(NV+ti2)) || (throwaway_zero == 0))
					{
					if(avg && (*(NV+ti2)))
						*(CONDV+ti3)+=(long)(*(V+ti2)/(*(NV+ti2)));
					else
						*(CONDV+ti3)+=(long)(*(V+ti2));
					(*(CONDNV+ti3))++;
/*				if(*(CONDV+ti3)<0l && !gazeanal)
fprintf(printer,"\nNEGATIVE CONDV: item %ld cond %ld seg %ld",ns+1,icond+1,region+1);*/
					}
				if(debug EQ 3)
					printf("\nCOLLAPSECOND: rel cond %d cond %d icond %d ns %d region %d CONDV %ld CONDNV %d",ic,cond+1,icond,ns+1,region+1,*(CONDV+ti3),*(CONDNV+ti3));
				} /* end for (region =0; region <nregmax; region++) */
			} /* end  if(*(ITEMCOND+ti1) EQ cond+1)  data for this subj,sen,&cond */

		}/* end         for(icond=0;icond<nscmax;icond++) */
} /* end collapsecond */



void pos_collapsecond(int ic,int cond,int nimin,int nimax,int nscmax,int nitot,int nctot)
{
int region,icond,ns,psample,sample,first_fixation,start_of_it;
int pti2;

for(ns=0;ns<nimax-nimin+1;ns++)	/* check all item/subcondition combos */
	for(icond=0;icond<nscmax;icond++)
		{
		ti1 = icond * nitot + ns;
		if(*(ITEMCOND+ti1) EQ cond+1)	/* data for this subj,sen,&cond */
			{
			for(sample=0;sample<cum_positions;sample++)
				{
				pti2 = sample*nctot + ic;	/* changed to relative cond # */
				ti3 = sample*nitot*nscmax + icond*nitot + ns;
				if(*(TCUMPOS+ti3) > -888)
					{									/* or after end of trial */
					*(CUMPOS+pti2) += *(TCUMPOS+ti3);
					(*(COUNT_CUMPOS+pti2))++;
					}
				}/* end for(sample=0,sample=1;sample<=cum_positions;sample++,sample++) */
			} /*end  if(*(ITEMCOND+ti1) EQ cond+1)   data for this subj,sen,&cond */
		} /* end for(icond=0;icond<nscmax;icond++) */
}/*end pos_collapsecond */



/* PRINT OUT SUMMARY VALUES */
/* and write item by item file averaged over subjects */
void summarize(int nimin,int nimax,int nscmax,int nregmax,int ncmin,int ncmax,int nitot,int nctot,int poke_anal,int anal,int around_end)
{
char temp[20];
int ns,nc,j,k,l,icond,cond,region;
int begin_print,end_print;
if(anal == 10 || anal == 14 || anal == 16)   /* eyegaze or spillover or totalgaze, just middle */
	{
	begin_print = 3;
	end_print = 4;
	}
else
	{
	begin_print = 0;
	end_print = nregmax;
	}
	
if(strlen(SysSenfileName) > 2)			/* write variable names */
	{
	for(nc=ncmin-1;nc<ncmax;nc++)
		for(j=begin_print;j<end_print;j++)
			fprintf(SysSenfile,"C%dR%d  ",nc+1,j+1);
		fprintf(SysSenfile,"\n");
	}
	
for(ns=0;ns<nitot;ns++)
	{
	if(anal != 15)
		{
		for(icond=0;icond <nscmax;icond++)
			{
			ti2 = icond*nitot + ns;
			if(strlen(SenfileName) > 2 || strlen(SysSenfileName) > 2)
				{
				if(!exceptflag || vexcept[ns] != 99)
					{
					if(strlen(SenfileName) > 2)
						fprintf(Senfile,"%5d%5d",ns+nimin,*(C+ti2));	/* new */
					for(region=begin_print;region<end_print;region++)
						{
						ti1 = region*nitot*nscmax + icond*nitot + ns;
						if(*(CUMNV+ti1))
							{
							if(mspc || (anal == 9 && poke_anal >= 2 && region != 3))
								{
								if(strlen(SenfileName) > 2)
									fprintf(Senfile,"%7.1f%3d",(float)(*(CUMV+ti1))/(10 * (float)(*(CUMNV+ti1))),*(CUMNV+ti1));
								if(strlen(SysSenfileName) > 2)
									fprintf(SysSenfile,"%7.1f",(float)(*(CUMV+ti1))/(10 * (float)(*(CUMNV+ti1))));
								}
							else
								{
								if(strlen(SenfileName) > 2)
									fprintf(Senfile,"%6ld%4d",*(CUMV+ti1)/(long)(*(CUMNV+ti1)),*(CUMNV+ti1));
								if(strlen(SysSenfileName) > 2)
									fprintf(SysSenfile,"%6ld",*(CUMV+ti1)/(long)(*(CUMNV+ti1)));
								}
							}/* end if(*(CUMNV+ti1)) */
						else  /* not  *(CUMNV+ti1)) */
							{
							if(mspc || (anal == 9 && poke_anal >= 2 && region != 3))
								{
								if(strlen(SenfileName) > 2)
									fprintf(Senfile,"    0.0  0");
								if(strlen(SysSenfileName) > 2)
									fprintf(SysSenfile,"    0.0");
								}
							else if(anal == 11)
								{
								if(strlen(SenfileName) > 2)
									fprintf(Senfile,"    -1   0");
								if(strlen(SysSenfileName) > 2)
									fprintf(SysSenfile,"    -1");
								}								
							else
								{
								if(strlen(SenfileName) > 2)
									fprintf(Senfile,"     0   0");
								if(strlen(SysSenfileName) > 2)
									fprintf(SysSenfile,"     0");
								}
							}/* end not  *(CUMNV+ti1))*/
						} /* end for(region=begin_print;region<end_print;region++) */
					if(strlen(SenfileName) > 2)
						fprintf(Senfile,"\n");
					} /* end        if(!exceptflag || vexcept[ns] != 99)*/
				}		/* end if strlen() */
			}/* end         for(icond=0;icond <nscmax;icond++) */
		if(strlen(SysSenfileName) > 2)
			fprintf(SysSenfile,"\n");
		}
	else			/* condition 15 */
		{
		for(icond=0;icond <nscmax;icond++)
			{
			fprintf(Senfile,"%5d%5d\n",ns+1,icond+1);	/* sen and condition number */
			for(k=0;k<nregmax;k++)	/* FROM region */
				{
				for(l=0;l<nregmax;l++)	/* TO region */
					{
					ti1 = k*nregmax*nscmax*nitot + l*nscmax*nitot + icond*nitot + ns;
					fprintf(Senfile,"%4d",(*(I_MATRIX+ti1)));
					}
				fprintf(Senfile,"\n");
				}  /* end  for(k=0;k<nregmax;k++) */
			} /* end of for(icond =0...) */
		}		/*  end of analysis 15 */
	}

if(anal != 15 && anal < 18)
{
fprintf(printer,"\n\nAVERAGED OVER ITEMS AND SUBJECTS, BY CONDITIONS\n");
printf("\n\nAVERAGED OVER ITEMS AND SUBJECTS, BY CONDITIONS\n");
if(anal == 9)       /* eyepoke */
	{
	fprintf(printer,"                                       ******");
	printf("                                       ******");
	}
if(mspc && around_end == 1 && anal != 5 && anal != 6 && anal != 7 && anal != 11)
	fprintf(printer,"\nWARNING! ms/char and dev from regr wrong when region wraps between lines.");
fprintf(printer,"\nMeans where each subject gets equal weight");
for(icond=0,cond=ncmin-1;cond<ncmax;icond++,cond++)
	{
	fprintf(printer,"\nCOND %2d ",cond+1);
	printf("\nCOND %2d ",cond+1);
	for(region=begin_print;region<end_print;region++)
		{
		if(region%7 == 0 && region > 0)
			{
			fprintf(printer,"\n       ");
			printf("\n       ");
			}
		ti1 = region*nctot + icond;
		if(*(CUMCNV+ti1))
			{
			if(mspc || (anal == 9 && poke_anal >= 2 && region != 3))
				{
				fprintf(printer,"%5.2f",(float)(*(CUMCV+ti1))/(10.0 * (float)(*(CUMCNV+ti1))));
				printf("%5.2f",(float)(*(CUMCV+ti1))/(10.0 * (float)(*(CUMCNV+ti1))));
				}
			else
				{
				fprintf(printer,"%5d",*(CUMCV+ti1)/(*(CUMCNV+ti1)));
				printf("%5d",*(CUMCV+ti1)/(*(CUMCNV+ti1)));
				}
			}
		else
			{
			fprintf(printer,"%5d",0);
			printf("%5d",0);
			}
		fprintf(printer," (%2d)",*(CUMCNV+ti1));
		printf(" (%2d)",*(CUMCNV+ti1));
		} /* end for region */
	} /* end for icond */
/* kludge to get unweighted means out */
fprintf(printer,"\n\nMeans where each response receives equal weight; under test - report problems please");
for(icond=0,cond=ncmin-1;cond<ncmax;icond++,cond++)
	{
	fprintf(printer,"\nCOND %2d ",cond+1);
	for(region=begin_print;region<end_print;region++)
		{
		if(region%7 == 0 && region > 0)
			fprintf(printer,"\n       ");
		ti1 = region*nctot + icond;
		if(*(CUMCNVT+ti1))
			{
			if(mspc || (anal == 9 && poke_anal >= 2 && region != 3))
				fprintf(printer,"%5.2f",(float)(*(CUMCVT+ti1))/(10.0 * (float)(*(CUMCNVT+ti1))));
			else
				fprintf(printer,"%5d",*(CUMCVT+ti1)/(*(CUMCNVT+ti1)));
			}
		else
			fprintf(printer,"%5d",0);
		fprintf(printer," (%2d)",*(CUMCNVT+ti1));
		} /* end for region */
	} /* end for icond */


printf("\nDo you want a typeout of the item-by-item data? y or n: ");
gets(temp);
if(tolower(temp[0])EQ 'y')
{
fprintf(printer,"\n\nSUMMARY BY ITEMS, AVERAGED OVER ALL SUBJECTS\n");
fprintf(printer,"\nINDIVIDUAL ITEM-SUBCONDITION COMBINATIONS\n");
for(ns=0;ns<nimax-nimin+1;ns++)
	for(icond=0;icond <nscmax;icond++)
		{
		fprintf(printer,"\nITEM %d SUBCOND %d ",ns+nimin,icond);
		for(region=begin_print;region<end_print;region++)
			{
			ti1 = region*nitot*nscmax + icond*nitot + ns;
			if(*(CUMNV+ti1))
				{
				if(mspc || (anal == 9 && poke_anal >= 2 && region != 3))
					fprintf(printer,"%5.2f",(float)(*(CUMV+ti1))/((float)(*(CUMNV+ti1))*10));
				else
					fprintf(printer,"%5d",*(CUMV+ti1)/(*(CUMNV+ti1)));
				}
			else
				fprintf(printer,"%5d",0);
			fprintf(printer,"(%2d)",*(CUMNV+ti1));
				} /* end for region*/
			} /*end for icond */
			fprintf(printer,"\n");
	}/*end typeout of item-by-item data */
}
} /*end summarize*/



void write_position_stuff(int ncmin,int ncmax,int nctot)
{
char temp[20];
FILE *pos_out;
int ns,ic,cond,sample;
int begin_print,end_print;
printf("\nName of file to contain summarized position info (CR if none): ");
tgets(temp,stdin);
if(strlen(temp) != 0)
	{
	if((pos_out = fopen(temp,"w")) == NULL)
		openfail(temp);
	fprintf(printer,"\nSummary output file name %s\n",temp);
	for(ic=0,cond=ncmin-1;cond<ncmax;ic++,cond++)
		{
		if(ic != 0)
			fprintf(pos_out,"\n");
		fprintf(pos_out,"COND %3d: ",cond+1);
		for(sample = 0; sample < cum_positions;sample++)
			{
			ti1 = sample*nctot + ic;
			if(*(COUNT_TOTAL_CUMPOS+ti1))
				fprintf(pos_out," %.2f",(*(TOTAL_CUMPOS+ti1))/(float)(*(COUNT_TOTAL_CUMPOS+ti1)));
			else
				fprintf(pos_out," -99.99");
			}
		fprintf(pos_out,"\nCOND %3d: ",cond+1);
		for(sample = 0; sample < cum_positions;sample++)
			{
			ti1 = sample*nctot + ic;
			fprintf(pos_out," %d",*(COUNT_TOTAL_CUMPOS+ti1));
			}
		} /*end for ic*/
	fclose(pos_out);
	} /*end if write to file */
}/* end write_position_stuff*/



/***************************************************************************/
/* get specified datum from buff */
int spacebuff(char *bptr,int val)
{
int i,j;
val--;
j=0;

if(val EQ 0)
	{
	while(isspace(*(bptr+j)))
		j++;
	return(j);
	}

for(i=0;i<val;i++)
	{
	while(isspace(*(bptr+j)))
		j++;    /* move to first/next nonspace */
	while(!isspace(*(bptr+j)))
		j++;    /* then move to next space */
	while(isspace(*(bptr+j)))
		j++;    /* and finally on to next nonspace */
	}
	j--;
return(j);
}/*end spacebuff*/



void oops(char *string)
{
printf("\nOut of allocation space at %s.",string);
exit(1);
}/*end oops*/


void movenextnumber()
{
while(isspace(*tbuff))  /* move on to next number */
	{
	if(*tbuff == '\n')
		return;
	tbuff++;
	}
while(!isspace(*tbuff))
	tbuff++;
while(isspace(*tbuff))
	tbuff++;
} /*end movenextnumber */


void movebacknumber()
{
while(!isspace(*tbuff))
	tbuff--;
while(isspace(*tbuff))
	tbuff--;
while(!isspace(*tbuff))
	tbuff--;
} /*end movebacknumber*/



/* routines for first fixation, total time, and first pass */

/*first fixation*/
int ff(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int region_length,int poke_anal,int StartPrevFix,int EndPrevFix)
{
/*printf("\nEntering ff, fixation %d start_region %d",fixation,start_region);*/
if(temppos >= end_region && temptime > shorttime)
	{
/*printf("\n passed end_region, fixation %d start_region %d",fixation,start_region);*/
	fixation = endsen;		/* past the region; cut it short */
	}
else if(temppos < start_region && *(NV+ti2) == 9999)
	fixation = endsen;		/* second fixation was a regression; zap it */
else if(temppos >= start_region && temppos < end_region)
	{
	if(temptime > longtime)				/* skip trials with initial long time fix */\
		{
		longs[fixation] = 1;
		if(chatter)			/* time longer than set for */
			fprintf(printer,"\nLONG:  Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d Reg from %4d to %4d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);
		fixation = endsen;
		*(V+ti2)=0;
		*(NV+ti2)=0;
		}
	else if(temptime <= shorttime)			/* ignore short time fixations */
		shorts[fixation] = 1;
	else if(temptime > shorttime && temptime <= longtime)
		{
/*printf("\nfixation %d start_region %d *NV %d",fixation,start_region,*(NV+ti2));
getchar();*/
		if(mspc == 1)
			temptime = myround(temptime*10,region_length);
		if(*(NV+ti2) == 0)		/* first fix only */
			{
			if(fixation == 0 && poke_anal == 5)
				fixation = endsen+1;
			else if(fixation > 0 && (StartPrevFix != 0 || poke_anal == 5))		/* filter on basis of prev fix */
				{
				if(PrevFixOK(start_region,shorttime,StartPrevFix,EndPrevFix,longtime) == 0)
					fixation = endsen+1;	/* set fake end trap */
				else if(poke_anal == 5 && temp_fixation > shorttime && temp_fixation <= longtime)				/* previous fixation, obtained from PrevFixOK() */
					{
					*(V+ti2) = temp_fixation;
					*(NV+ti2) = 1;
					fixation = endsen+1;
/*printf("\n  temp_fixation %d fixation %d",temp_fixation,fixation);*/
					}
				}
			if(fixation != endsen+1)			/* still have work to do */
				{
				*(V+ti2)=temptime;
/*printf("\n fixation not endsen+1; V %d",*(V+ti2));*/
				if(poke_anal == 3 || poke_anal == 4)		/* only multiple fixations or second fix*/
					*(NV+ti2) = 9999;
				else
					(*(NV+ti2)) = 1;
				if(poke_anal == 1)		/* all first fixations */
					fixation = endsen;	/* cut the loop short */
				}
			else
				fixation = endsen;		/* really end it */
			}
		else if(poke_anal == 2)	/* only single fixations */
			{
			*(V+ti2)=0;
			*(NV+ti2)=0;
			fixation = endsen;
			}
		else if(poke_anal == 3)	/* only multiple fixations */
			{
			*(NV+ti2) = 1;
			fixation = endsen;			
			}
		else if(poke_anal == 4)	/* only second fixation */
			{
			if(*(NV+ti2) == 9999)		/* pick out exactly second */
				{
				*(V+ti2) = temptime;
				*(NV+ti2) = 1;
				}
			}
		if(*(V+ti2) < 0)
			fprintf(printer,"\nNEGATIVE V: item %d cond %d region %d",sptrptr,cptrptr,region);
		} /*end if valid time */
	else if(temptime <= shorttime && chatter)
		fprintf(printer,"\nSHORT: Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d Reg from %4d to %4d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);
	if(debug EQ 2)
		{
		printf("\nGOT FIX: REGION = %d fix = %d NS = %d V = %d NV = %d",region,fixation,ns,*(V+ti2),*(NV+ti2));
		fprintf(printer, "\nFF: region = %d time %d length %d",region,*(V+ti2), region_length);
		}
	}/*end if in region*/
if(fixation == endsen && *(NV+ti2) == 9999)
	*(NV+ti2) = 0;
return(fixation);
}/*end ff */

/*Jane's landing & launch analysis*/
int landlaunch(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int region_length,int ncmin,int nimin,int nscmax,int StartPrevFix,int EndPrevFix)
{
int wordlength,landposit,launchposit;
static int lastposit;
if(temppos >= end_region && temptime > shorttime)
	fixation = endsen;		/* past the region; cut it short */
else if(temppos >= start_region && temppos < end_region)
	{
	if(temptime > longtime)				/* skip trials with initial long time fix */\
		{
		longs[fixation] = 1;
		if(chatter)			/* time longer than set for */
			fprintf(printer,"\nLONG:  Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d Reg from %4d to %4d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);
		fixation = endsen;
		*(V+ti2)=0;
		*(NV+ti2)=0;
		}
	if(temptime <= shorttime)			/* ignore short time fixations */
		shorts[fixation] = 1;
	if(temptime > shorttime && temptime <= longtime)
		{
		if(fixation == 1)
			lastposit = temppos;
		else
		{
		if(*(NV+ti2) == 0)		/* first fix only */
			{
			if(StartPrevFix != 0)		/* filter on basis of prev fix */
				{
				if(PrevFixOK(start_region,shorttime,StartPrevFix,EndPrevFix,longtime) == 0)
					{
					fixation = endsen+1;	/* set fake end trap */
					}
				}
			if(fixation != endsen+1)	
				{
				wordlength = region_length - 5;
				if(wordlength < 0)
					wordlength = 0;
				else if (wordlength > 4)
					wordlength = 4;										/* word length: 4, 5, 6, 7, 8+ letters */
				landposit = temppos - start_region;			/* landing position in word */
				(*(CUM_MATRIX + (cptrptr-ncmin)*6*8 + wordlength*8 + landposit))++;
				(*(S_MATRIX + (cptrptr-ncmin)*6*8 + wordlength * 8 + landposit))++;
				(*(I_MATRIX + (sptrptr-nimin)*nscmax*6*8 + (cptrptr-ncmin)*6*8 + wordlength*8 + landposit))++;
				launchposit = start_region - lastposit - 1; 
				if(launchposit < 0)
					launchposit = 0;			/* ok it's impossible but.... */
				else if(launchposit > 7)
					launchposit = 7;
				(*(CUM_MATRIX + (cptrptr-ncmin)*6*8 + 5*8 + launchposit))++;
/*			CUM_MATRIX[cptrptr-ncmin][5][launchposit]++;*/
/*			LaunchSite[launchposit]++;*/
				(*(NV+ti2)) = 1;
				fixation = endsen;	/* cut the loop short */
				}
			}
		}
		} /*end if valid time */
	else if(temptime <= shorttime && chatter)
		fprintf(printer,"\nSHORT: Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d Reg from %4d to %4d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);
	if(debug EQ 2)
		{
		printf("\nGOT FIX: REGION = %d fix = %d NS = %d V = %d NV = %d",region,fixation,ns,*(V+ti2),*(NV+ti2));
		fprintf(printer, "\nLL: region = %d time %d length %d",region,*(V+ti2), region_length);
		}
	}/*end if in region*/
else
	lastposit = temppos;
return(fixation);
}/*end ll */



int tt(int fixation,int temppos,int temptime,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int region_length,int StartPrevFix,int EndPrevFix,int endsen)
{
if(temppos >= start_region && temppos < end_region)
	{
	if(temptime > longtime)				/* discard trials with longtime */
		{
		longs[fixation] = 1;
		fixation = endsen;
		if(chatter)			/* time longer than set for */
			fprintf(printer,"\nLONG:  Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d Reg from %4d to %4d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);
		}
	if(temptime <= shorttime)			/* skip short fixations */
		shorts[fixation] = 1;
	if(temptime > shorttime && temptime <= longtime)
		{
		if(fixation > 0 && StartPrevFix != 0 && *(NV+ti2) == 0)		/* filter on basis of prev fix */
			{
			if(PrevFixOK(start_region,shorttime,StartPrevFix,EndPrevFix,longtime) == 0)
				{
				fixation = endsen+1;
				}
			}
		if(fixation != endsen+1)
			{
			if(mspc == 1)
					temptime = myround(temptime*10,region_length);
			*(V+ti2)+=temptime;
			(*(NV+ti2))++;
			if(*(V+ti2) < 0)
				fprintf(printer,"\nNEGATIVE V: item %d cond %d region %d",sptrptr,cptrptr,region);
			if(*(NV+ti2) > 0)
				{
				if(*(V+ti2) > ttcutoff)
					{
					fprintf(printer,"\n Long tt duration %d: item %d cond %d region %d",*(V+ti2),sptrptr,cptrptr,region+1);
					*(V+ti2) = 0;
					*(NV+ti2) = 0;
					fixation = endsen+1;
					}
				}
			}
		else
			fixation = endsen;
		}
	else if(temptime <= shorttime && chatter)
	fprintf(printer,"\nSHORT: Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d Reg from %4d to %4d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);
	if(debug EQ 2)
		{
		printf("\nGOT FIX: REGION = %d fix = %d NS = %d V = %d NV = %d",region,fixation,ns,*(V+ti2),*(NV+ti2));
		fprintf(printer, "\nTT: region = %d time %d length %d",region,*(V+ti2), region_length);
		}
	} /*end if in region */
return(fixation);
} /*end tt*/





/*
	1 = include only time in region after going past it
	2 = include all re-reading time after leaving region, left or right
	3 = include only time in region after leaving it to left, before going past
*/

sec_pass(int fixation,int temppos,int temptime,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int *past_region,int *in_region,int poke_anal,int region_length,int endsen,int start_trigger_region, int end_trigger_region)
{
if(throwaway_zero == 0)
	if((*(NV+ti2)) == 0)		/* keep zero trials */
		*(NV+ti2) = 1;
if(poke_anal == 3 && temppos >= end_region && temptime > shorttime)
	fixation = endsen;
else
{
if(poke_anal == 4)		/* Tim Kludge */
	{
	if(temppos >= start_trigger_region && temppos <= end_trigger_region && temptime > shorttime)
		*past_region = 1;		/* set to true */
	}
else if	(temppos >= end_region && temptime > shorttime)
	*past_region = 1;		/* set to true */
if(poke_anal == 2 || poke_anal == 3)		/* including rereading time before go past */
	{
	if(*in_region == 1 && temppos < start_region)
		*past_region = 1;
	if(temppos >= start_region && temppos < end_region && *in_region == 0)
		{
		if(temptime > shorttime && temptime <= longtime)
			*in_region = 1;
		}
	}
}
/* KLUDGE to set second pass straight and include time in region after
regressing out of it but before going past it */

if(temppos >= start_region && temppos < end_region && (*past_region) == 1)
	{
	if(temptime > longtime)
		{			/* throw out all trials with a long fixation in 2nd pass */
		longs[fixation] = 1;
		*(V+ti2) = 0;
		(*(NV+ti2)) = 0;
		fixation = endsen;
		if(chatter)			/* time longer than set for */
			fprintf(printer,"\nLONG:  Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d Reg from %4d to %4d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);
		}
	if(temptime <= shorttime)
		shorts[fixation] = 1;
	else if(temptime > shorttime && temptime <= longtime)
		{
		if(poke_anal == 2)
			*in_region = 1;
		if(mspc == 1)
			temptime = myround(temptime*10,region_length);
/* fix for old error, counting 1 too many fixations in sec pass with throwaway_zero == 0 */
		if(*(V+ti2) > 0 || throwaway_zero == 1)
			(*(NV+ti2))++;		/* starts at 1 for throwaway_zero == 0; leave it at 1 for the first fixation */
		*(V+ti2)+=temptime;
		if(*(V+ti2) < 0)
			fprintf(printer,"\nNEGATIVE V: item %d cond %d region %d",sptrptr,cptrptr,region);
		}
	else if(temptime <= shorttime && chatter)
		fprintf(printer,"\nSHORT: Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d Reg from %4d to %4d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);

	if(debug EQ 2)
		{
		printf("\nGOT FIX: REGION = %d fix = %d NS = %d V = %d NV = %d",region,fixation,ns,*(V+ti2),*(NV+ti2));
		fprintf(printer, "\nSecondPass: region = %d time %d length %d",region,*(V+ti2), region_length);
		}

	} /* end if in region*/
return(fixation);
}/*end sec_pass*/


fp(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int region_length,int StartPrevFix,int EndPrevFix)
{
double ftemptime;
int otemptime;
if(temppos >= end_region && temptime > shorttime)
	fixation = endsen;		/* past the region; cut it short */
else if(temppos < start_region && *(NV+ti2) != 0)	/* regress to before region */
	fixation = endsen;
else if(temppos >= start_region && temppos < end_region)
	{
	if(temptime > longtime)				/* discard trials with overlong fix */
		{
		longs[fixation] = 1;
		*(V+ti2) = 0;
		(*(NV+ti2)) = 0;
		fixation = endsen;
		if(chatter)			/* time longer than set for */
			{
			fprintf(printer,"\nLONG:  Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d Reg from %4d to %4d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);
			}
		}
	if(temptime <= shorttime)			/* skip short fixations */
		shorts[fixation] = 1;
	if(temptime > shorttime && temptime <= longtime)
		{
		if(fixation > 0 && StartPrevFix != 0 && *(NV+ti2) == 0)		/* filter on basis of prev fix */
			{
			if(PrevFixOK(start_region,shorttime,StartPrevFix,EndPrevFix,longtime) == 0)
				{
				fixation = endsen+1;
				}
			}
		if(fixation != endsen+1)
			{
			if(mspc == 1)
				temptime = myround(temptime*10,region_length);
			*(V+ti2)+=temptime;
			(*(NV+ti2))++;
			if(*(V+ti2) < 0 && mspc != 2)
				fprintf(printer,"\nNEGATIVE V: item %d cond %d region %d",sptrptr,cptrptr,region);
			if(*(V+ti2) > fpcutoff)
				{
				fprintf(printer,"\n Long gaze duration %d: item %d cond %d region %d",*(V+ti2),sptrptr,cptrptr,region+1);
				*(V+ti2) = 0;
				*(NV+ti2) = 0;
				fixation = endsen+1;
				}
			}
		else
			fixation = endsen;	/* set endsen+1 to endsen */
		}
	else if(temptime <= shorttime && chatter)
		fprintf(printer,"\nSHORT: Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d Reg from %4d to %4d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);
	if(debug EQ 2)
		{
		printf("\nGOT FIX: REGION = %d fix = %d NS = %d V = %d NV = %d",region,fixation,ns,*(V+ti2),*(NV+ti2));
		fprintf(printer, "\nFP: region = %d time %d length %d",region,*(V+ti2), region_length);
		}
	}/*end in region*/
return(fixation);
} /*end fp*/



check_reg(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int region,int ns)
{
int nextpos,nexttime,tempx,tempy,temps,tempe,ii;
if(temppos >= end_region && temptime > shorttime)
	fixation = endsen;		/* past the region; cut it short */
/*else if(temppos < start_region && *(NV+ti2) != 0)
	fixation = endsen;*/	/* regress to before region */
else if(temppos >= start_region && temppos < end_region)
	{
	if(debug == 2)
		printf("\nGOT FIX IN CHECK_REG: REGION = %d fix = %d NS = %d V = %d NV = %d",region,fixation,ns,*(V+ti2),*(NV+ti2));
	if(temptime > shorttime && temptime <= longtime)
		{
		tempx = atoi(tbuff);
		movenextnumber();
		tempy = atoi(tbuff);
		movenextnumber();
		temps = atoi(tbuff);
		movenextnumber();
		tempe = atoi(tbuff);
		nextpos = tempx + (tempy-yoffset) * width;
		nexttime = tempe-temps;
		for(ii=3;ii>0;ii--)
			movebacknumber();
		if(debug == 2)
			printf("\n checking fix at tempx %d tempy %d, position %d time %d",tempx,tempy,nextpos,nexttime);
		if(nextpos < start_region && nextpos > 0 && nexttime > shorttime && nexttime < longtime)	/* regression */
			{
			if(debug == 2)
				printf("\n  AND GOT REGRESSION THERE TOO, nextpos = %d\n",nextpos);
			return(-1);
			}
		} /* end if in time range*/
	} /*end if in region*/
return(fixation);
} /*end check_reg*/


check_fix(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int region,int ns)
{
int nextpos,nexttime,tempx,tempy,temps,tempe,ii;
if(temppos >= end_region && temptime > shorttime)
	fixation = endsen;		/* past the region; cut it short */
/*else if(temppos < start_region && *(NV+ti2) != 0)
	fixation = endsen;*/	/* regress to before region */
else if(temppos >= start_region && temppos < end_region)
	{
	if(debug == 2)
		printf("\nGOT FIX IN CHECK_REG: REGION = %d fix = %d NS = %d V = %d NV = %d",region,fixation,ns,*(V+ti2),*(NV+ti2));
	if(temptime > shorttime && temptime <= longtime)
		return(-1);
	} /*end if in region*/
return(fixation);
} /*end check_fix*/





oreg(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns)
{
int nextpos,nexttime,tempx,tempy,temps,tempe,ii;
if(temppos >= end_region && temptime > shorttime)
	fixation = endsen;		/* past the region; cut it short */
/*else if(temppos < start_region && *(NV+ti2) != 0)
	fixation = endsen;*/	/* regress to before region */
else if(temppos >= start_region && temppos < end_region)
	{
	if(temptime > longtime)
		longs[fixation] = 1;
	if(temptime <= shorttime)
		shorts[fixation] = 1;
	if(debug == 2)
		printf("\nGOT FIX, CHECK FOR REG: REGION = %d fix = %d NS = %d V = %d NV = %d",region,fixation,ns,*(V+ti2),*(NV+ti2));
	if(temptime > longtime && chatter)			/* time longer than set for */
		{
		fprintf(printer,"\nLONG:  Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d Reg from %4d to %4d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);
		}
	else if(temptime > shorttime && temptime <= longtime)
		{
		tempx = atoi(tbuff);
		movenextnumber();
		tempy = atoi(tbuff);
		movenextnumber();
		temps = atoi(tbuff);
		movenextnumber();
		tempe = atoi(tbuff);
		nextpos = tempx + (tempy-yoffset) * width;
		nexttime = tempe-temps;
		for(ii=3;ii>0;ii--)
			movebacknumber();
		if(nextpos < start_region && nextpos > 0 && nexttime > shorttime && nexttime < longtime)	/* regression */
			{
			*(V+ti2) = 100;		/* compute in PERCENTAGES */
			if(debug == 2)
				printf("\n  GOT REGULAR REGRESSION TOO, nextpos = %d\n",nextpos);
			}
		*(NV+ti2) = 1;		/* just indicate whether any fixations in region */
		if(*(V+ti2) < 0)
			fprintf(printer,"\nNEGATIVE V: item %d cond %d region %d",sptrptr,cptrptr,region);
		}
	else if(temptime <= shorttime && chatter)
		fprintf(printer,"\nSHORT: Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d Reg from %4d to %4d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);
	} /*end if in region*/
return(fixation);
}/*end oreg*/


ireg(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns)
{
int lastpos,lasttime,tempx,tempy,temps,tempe,ii;
if(temppos >= start_region && temppos < end_region)
	{
	if(temptime > longtime)
		longs[fixation] = 1;
	if(temptime <= shorttime)
		shorts[fixation] = 1;
	if(debug EQ 2)
		printf("\nGOT FIX: REGION = %d fix = %d NS = %d V = %d NV = %d",region,fixation,ns,*(V+ti2),*(NV+ti2));
	*(NV+ti2) = 1;		/* just indicate whether any fixations in region */
						/* CHANGE 7/14/89: set to 1 for every sentence, every region */
	if(temptime > longtime && chatter)			/* time longer than set for */
		{
		fprintf(printer,"\nLONG:  Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d Reg from %4d to %4d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);
		}
	else if(temptime > shorttime && temptime <= longtime)
		{
		for(ii=8;ii>0;ii--)
			movebacknumber();
		tempx = atoi(tbuff);
		movenextnumber();
		tempy = atoi(tbuff);
		movenextnumber();
		temps = atoi(tbuff);
		movenextnumber();
		tempe = atoi(tbuff);
		for(ii=5;ii>0;ii--)
			movenextnumber();
		lastpos = tempx + (tempy-yoffset) * width;
		lasttime = tempe-temps;
    if(lastpos >= end_region && lasttime > shorttime && lasttime < longtime && tempy >= 0 && tempy <= max_y) /* regression */
			{
			*(V+ti2) = 100;		/* compute in PERCENTAGES */
			fixation = endsen;	/* and stop looking at region */
			if(debug == 2)
				printf("\n  AND GOT REGRESSION TOO, lastpos = %d tempx = %d tempy = %d\n",lastpos,tempx,tempy);
			}
		if(*(V+ti2) < 0)
			fprintf(printer,"\nNEGATIVE V: item %d cond %d region %d",sptrptr,cptrptr,region);
		}
	else if(temptime <= shorttime && chatter)
		fprintf(printer,"\nSHORT: Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d Reg from %4d to %4d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);
	}  /*end if in region*/
return(fixation);
} /*end ireg*/



p_init_fix(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int poke_anal,int StartPrevFix,int EndPrevFix,int nregion)
{
static int gotfix,gotlastfix,lastregion;
int ii, lastpos, lasttime,tempx,tempy,temps,tempe;
if(fixation == 0)
	gotfix = 0;
if(region == 0)		/* corrected 6/7/04 */
	gotlastfix = 0;
if(region > 0)
	if(region > lastregion)
		{
		gotfix = 0;
		lastregion = region;
		}
if(poke_anal > 2)		/* zero out frequency counts */
	{
	*(V+ti2) = 0;
	*(NV+ti2) = 0;
	if(debug == 2)
		printf("\nregion %d fixation %d nregion %d",region,fixation,nregion);
	}
if(StartPrevFix == 0 && poke_anal <= 2)
	*(NV+ti2) = 1;		/* just indicate whether region processed */
if(temppos >= end_region && temptime > shorttime)
	{
	if(gotfix == 0)
		gotlastfix = 0;				/* skipped current region */
	if(poke_anal <= 2)		/* getting prob of fixs */
		{
		if(StartPrevFix != 0)		/* conditionalizing */
			{
			if(*(V+ti2) == 0)		/* must have skipped */
				if(PrevFixOK(start_region,shorttime,StartPrevFix,EndPrevFix,longtime) != 0)
					*(NV+ti2) = 1;		/* previous fixation was legal */
			}
		}
	else if(poke_anal >= 3 && poke_anal <=4 && gotfix == 0 && region != nregion-1 && fixation > 0 && fixation < endsen-1)		/* don't do it for last region or for last 1 fixations */
		{
		if(debug == 2)
			printf("\n  PAST REGION %d at fixation %d",region,fixation);
		if(poke_anal == 3)		/* last fixation before skip */
			{
			for(ii=8;ii>0;ii--)
				movebacknumber();
			movenextnumber();
			movenextnumber();
			temps = atoi(tbuff);
			movenextnumber();
			tempe = atoi(tbuff);
			for(ii=5;ii>0;ii--)
				movenextnumber();
			lasttime = tempe-temps;
			if(lasttime > shorttime)
				{
				*(V+ti2) = lasttime;
				*(NV+ti2) = 1;
				}
			}
		else if(poke_anal == 4)		/* first fixation after skip */
			{
			*(V+ti2) = temptime;
			*(NV+ti2) = 1;
			}
		if(debug == 2)
			printf("\nFound skip: Set V to %d",*(V+ti2));
		}
	else if(poke_anal == 6 && gotfix == 1 && region != 0 && fixation > 0 && fixation <= endsen-1)		/* don't do it for last region or for last 1 fixations */
		{				/* get first fix in region after landing in prev region */
		if(debug == 2)
			printf("\n  PAST FIXATED REGION %d at fixation %d",region,fixation);
		*(V+ti2) = temptime;
		*(NV+ti2) = 1;
		if(debug == 2)
			printf("\nFound fix after land: Set V to %d",*(V+ti2));
		}
	else		/* in last region or next to last fixation*/
		{
		*(V+ti2) = 0;
		*(NV+ti2) = 0;
		if(debug == 2)
			printf("\nZeroed V");
		}
	lastregion = region;		/* went past region */
	fixation = endsen;		/* past the region; cut it short */
	if(debug == 2)
		printf("\nsetting fixation to endsen in p_init_fix, region %d lastregion %d",region,lastregion);
	}
else if(temppos >= start_region && temppos < end_region)
	{
	if(temptime > longtime)
		longs[fixation] = 1;
	if(temptime <= shorttime)
		shorts[fixation] = 1;
	if(StartPrevFix == 0 || PrevFixOK(start_region,shorttime,StartPrevFix,EndPrevFix,longtime) != 0)
		{
		if(temptime > shorttime)
			{
			gotfix = 1;
			if(poke_anal <= 2)
				{
				*(V+ti2) += 100;		/* compute in PERCENTAGES */
				*(NV+ti2) = 1;
				}
			if(poke_anal == 5 && gotlastfix == 1 && region != 0)		/* last fixation before land */
				{
				for(ii=8;ii>0;ii--)
					movebacknumber();
				movenextnumber();
				movenextnumber();
				temps = atoi(tbuff);
				movenextnumber();
				tempe = atoi(tbuff);
				for(ii=5;ii>0;ii--)
					movenextnumber();
				lasttime = tempe-temps;
				if(lasttime > shorttime)
					{
					*(V+ti2) = lasttime;
					*(NV+ti2) = 1;
					}
				fixation = endsen;			/* recorded fixation in region n after landing in n-1 */
				}
			gotlastfix = 1;				/* got fixation in a region */
			}
		else if(temptime <= shorttime && chatter)
			fprintf(printer,"\nSHORT: Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d Reg from %4d to %4d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);
		}
	if(debug EQ 2)
		printf("\nGOT FIX: reg = %d fix = %d NS = %d V = %d NV = %d gotfix %d",region,fixation,ns,*(V+ti2),*(NV+ti2),gotfix);
	}
/*printf("\nfixation %d temppos %d startregion %d value %d poke_anal %d",fixation,temppos,start_region,*(V+ti2),poke_anal);*/

if(*(V+ti2) > 100 && poke_anal <= 2)
	{
	if(poke_anal == 2)		/* getting prob of exactly 1 fix */
			{
			*(V+ti2) = 0;
			fixation = endsen;
			}
	else
			{
			*(V+ti2) = 100;
			fixation = endsen;
			}
	}
if(poke_anal > 2 && debug == 2)
	{
	printf("\nExiting p_init with gotfix %d reg %d fix %d V %d poke_anal %d endsen %d\nPress q to quit: ",gotfix,region,fixation,*(V+ti2),poke_anal,endsen);		
	if(getchar() == 'q')
		exit(1);
	}
return(fixation);
} /*end p_init_fix*/



void openfail(char *filestr)
{
printf("\nCan't open file %s. ",filestr);
exit(1);
}


	
int no_fixes(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int poke_anal)
{
mspc = 1;
*(NV+ti2) = 1;		/* just indicate whether region processed */
if(poke_anal == 1 && temppos >= end_region && temptime > shorttime)
	 fixation = endsen;      /* past the region; cut it short */
else if(temppos >= start_region && temppos < end_region)
	{
	if(temptime > longtime)
		longs[fixation] = 1;
	if(temptime <= shorttime)
		shorts[fixation] = 1;
	if(temptime > shorttime)
		{
		*(V+ti2) += 10;     /* count by 10s */
		}
	else if(temptime <= shorttime && chatter)
		fprintf(printer,"\nSHORT: Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d Reg from %4d to %4d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);
	if(debug EQ 2)
		printf("\nGOT FIX: REGION = %d fix = %d NS = %d V = %d NV = %d",region,fixation,ns,*(V+ti2),*(NV+ti2));
	}
else if(poke_anal == 1 && *(V+ti2) && temppos < start_region)
    fixation = endsen;      /* went to before start of region after entering */
return(fixation);
}/*end no_fixes*/



/* routines for eyepoke */


int fixes(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int nitot,int nscmax,int icond,int poke_anal,int ik,int region_length)
{
char *xtbuff;		/* temp pointer for critical fixation */
int lastpos;
int ii,index,tii;
int tempx,tempy,temps,tempe,newpos,newtime,saccade_length;
lastpos = temppos;
if(temppos >= end_region && temptime > shorttime)
	fixation += endsen;		/* past the region; cut it short */
									/* but send back info about fixation */
else if(temppos >= start_region && temppos < end_region)
	{
	if(temptime <= shorttime)
		shorts[fixation] = 1;
	if(temptime > longtime)			/* time longer than set for */
		{
		longs[fixation] = 1;
		got_fix = 2;		/* set panic flag */
		*(V+ti3)=0;			/* zero out region */
		(*(NV+ti3))=0;
		fixation += endsen;			/* end the search; got_fix == will terminate */
		if(chatter)
			fprintf(printer,"\nLONG:  Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d Reg from %4d to %4d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);
		}
	else if(temptime > shorttime && temptime < longtime)
		{
		ti3 = 3*nitot*nscmax + icond*nitot + ns;
		if(*(NV+ti3) == 0)		/* first fix only */
			{
			got_fix = 1;		/* indicate you got a fixation */
			if(mspc == 1)
				temptime = myround(temptime*10,region_length);
			*(V+ti3)=temptime;
			(*(NV+ti3))++;
			xtbuff = tbuff;	/* temporarily set pointer where you are */
			if(fixation < 3)	/* not enough fixations */
				index = 3-fixation;		/* remember, count from 0 */
			else
				index = 0;
			for(ii=4;ii>0;ii--)
				movebacknumber();
			for(ii=2,tii=2;ii>= index;ii--,tii--)
				{
				loop1:
				movebacknumber();	/* back no more than three fixes */
				tempe = atoi(tbuff);
				movebacknumber();
				temps = atoi(tbuff);
				movebacknumber();
				tempy = atoi(tbuff);
				movebacknumber();
				tempx = atoi(tbuff);
				newpos = tempx + (tempy-yoffset) * width;
				newtime = tempe-temps;
				if(newtime <= shorttime)
					{				/* short fixation, discard, get next in position */
					ii--;
					goto loop1;
					}
				else if(newtime > longtime || tempy < 0 || tempy > max_y)
					{				/* long time, out of bounds; stop analyzing */
					ii = index;
					goto end1;
					}
				ti3 = (tii)*nitot*nscmax + icond*nitot + ns;
				if(mspc)
					newtime = myround(newtime*10,region_length);
				if(poke_anal == 1)
					{
					*(V+ti3)=newtime;
					(*(NV+ti3)) = 1;
					}
				else
					{  /* poke_anal != 1*/
					saccade_length = 10*(lastpos - newpos);	/* signed value of distance */
					while(saccade_length >= 800)			
						saccade_length -= 800;
				  if(poke_anal == 4)
          	{
						if(saccade_length > 0)
							*(V+ti3) = 10;
						(*(NV+ti3)) = 1;
						lastpos = newpos;
						}
					else if(poke_anal == 2 || saccade_length > 0)
						{
						*(V+ti3)=saccade_length;
						(*(NV+ti3)) = 1;
						lastpos = newpos;
						}
					else			/* stop analyzing when get regression */
						{
						ii = index;
						goto end1;
						}
					} /* end poke_anal != 1*/
				if(debug == 2)
					printf("\nx %d y %d stime %d etime %d ti3 %d",tempx,tempy,temps,tempe,ti3);
				end1:
                if(*(V+ti3) < 0 && ((!gazeanal) || poke_anal == 1))
					fprintf(printer,"\nNEGATIVE V: value %d item %d cond %d region %d fixation %d ii %d",*(V+ti3),sptrptr,cptrptr,region,fixation+1,ii);
				} /* end for ii=2, tii = 2; ii>=indix; ii--, tii-- */
			tbuff = xtbuff; /* restore pointer */
			lastpos = temppos;
			if(endsen-fixation <= 3)	/* not enough fixations */
				index = ((endsen-1)-fixation);
			else
				index = 3;
			for(ii=1,tii=1;ii<=index;ii++,tii++)	/* pick up 3 fixes */
				{
				loop2:
				tempx = atoi(tbuff);
				movenextnumber();
				tempy = atoi(tbuff);
				movenextnumber();
				temps = atoi(tbuff);
				movenextnumber();
				tempe = atoi(tbuff);
				movenextnumber();	
				newpos = tempx + (tempy-yoffset) * width;
				newtime = tempe-temps;
				if(newtime <= shorttime)
					{				/* short fixation, discard, get next in position */
					ii++;
					goto loop2;
					}
				else if(newtime > longtime || tempy < 0 || tempy > max_y)
					{				/* long time, out of bounds; stop analyzing */
					ii = index;
					goto end2;
					}
				ti3 = (3 + tii)*nitot*nscmax + icond*nitot + ns;

				if(mspc)
					newtime = myround(newtime*10,region_length);

				if(poke_anal == 1)
					{
					*(V+ti3)=newtime;
					(*(NV+ti3)) = 1;
					}
				else
					{ /* poke_anal != 4*/
					saccade_length = 10*(newpos - lastpos);	/* signed value of distance */
					while(saccade_length >= 800)		
						saccade_length -= 800;
          if(poke_anal == 4)
						{
						if(saccade_length > 0)
							*(V+ti3) = 10;
						(*(NV+ti3)) = 1;
						lastpos = newpos;
						}
					else if(poke_anal == 2 || saccade_length > 0)
						{
						*(V+ti3)=saccade_length;
						(*(NV+ti3)) = 1;
						lastpos = newpos;
						}
					else			/* stop analyzing when get regression */
						ii = index;
					}/* end poke_anal != 1*/
				end2:
				if(*(V+ti3) < 0 && ((!gazeanal) || poke_anal == 1))
					fprintf(printer,"\nNEGATIVE V: value %d item %d cond %d region %d fixation %d ii %d",*(V+ti3),sptrptr,cptrptr,region,fixation+1,ii);
				} /* end        for(ii=1,tii=1;ii<=index;ii++,tii++)   pick up 3 fixes */
			fixation = endsen;      /* cut the loop short */
			tbuff = xtbuff; /* restore it */
			} /* end if (*(NV+ti3)==0) first fix only */
		} /* end if temptime > shorttime && temptime < longtime */
	else if(temptime <= shorttime && chatter && ik == 0)
		fprintf(printer,"\nSHORT: Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d Reg from %4d to %4d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);
	if(debug EQ 2)
		{
		printf("\nGOT FIX: REGION = %d fix = %d NS = %d V = %d NV = %d",region,fixation,ns,*(V+ti3),*(NV+ti3));
		}
	} /*end if temppos within region */
return(fixation);
}/* end fixes*/


int following_fixes(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int nitot,int nscmax,int icond,int poke_anal,int region_length)
{
char *xtbuff;		/* temp pointer for critical fixation */
int ii,index;
int tempy,temps,tempe,newtime,saccade_length;
if(temptime > longtime && chatter)			/* time longer than set for */
	fprintf(printer,"\nLONG:  Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d Reg from %4d to %4d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);
xtbuff = tbuff;	/* temporarily set pointer where you are */

ti3 = (3+1)*nitot*nscmax + icond*nitot + ns;	/* start after crit. region */
if(mspc)
	temptime = myround(temptime*10,region_length);
*(V+ti3)=temptime;
(*(NV+ti3))++;
if(endsen-fixation <= 2)	/* not enough fixations */
	index = ((endsen-1)-fixation);
else
	index = 2;
for(ii=1;ii<=index;ii++)	/* pick up 2 more fixes */
	{
/*	tempx = atoi(tbuff);*/
	movenextnumber();
	tempy = atoi(tbuff);
	movenextnumber();
	temps = atoi(tbuff);
	movenextnumber();
	tempe = atoi(tbuff);
	movenextnumber();
	newtime = tempe-temps;
	if(newtime <= shorttime || newtime > longtime || tempy < 0 || tempy > max_y)
		goto end3;	/* scrap short, long out of bounds fixations */
	ti3 = (3+1+ii)*nitot*nscmax + icond*nitot + ns;		/* keep long fix trials, discard long fix */
	if(mspc)
		newtime = myround(newtime*10,region_length);
	if(poke_anal == 1)
		{
		*(V+ti3)=newtime;
		(*(NV+ti3)) = 1;
		}				/* don't use following_fixes() when computing lengths */
	end3:
    if(*(V+ti3) < 0 && ((!gazeanal) || poke_anal == 1))
			fprintf(printer,"\nNEGATIVE V: value %d item %d cond %d region %d fixation %d ii %d",*(V+ti3),sptrptr,cptrptr,region,fixation+1,ii);
	} /*end   for(ii=1;ii<=index;ii++)       pick up 2 more fixes */
tbuff = xtbuff; /* restore it */
return(fixation);
} /* end following_fixes*/



int gd_fixes(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int nitot,int nscmax,int icond,int ik,int region_length)
{
ti3 = 3*nitot*nscmax + icond*nitot + ns;
if(temppos >= end_region && temptime > shorttime)
	fixation = endsen;		/* past the region; cut it short */
else if(temppos < start_region && *(NV+ti3) != 0)	/* regress to before region */
	fixation = endsen;
else if(temppos >= start_region && temppos < end_region)
	{
	if(temptime <= shorttime)
		shorts[fixation] = 1;
	if(temptime > longtime)			/* time longer than set for */
		{
		longs[fixation] = 1;
		got_fix = 2;		/* set panic flag */
		*(V+ti3)=0;			/* zero out region */
		(*(NV+ti3))=0;
		fixation += endsen;			/* end the search; got_fix == will terminate */
		if(chatter)
			fprintf(printer,"\nLONG:  Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d Reg from %4d to %4d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);
		}
	else if(temptime > shorttime && temptime <= longtime)
		{
		got_fix = 1;			/* indicate there was a fix in the region */
		if(mspc)
			temptime = myround(temptime*10,region_length);
		*(V+ti3)+=temptime;
		(*(NV+ti3))++;
		if(*(V+ti3) < 0)
			fprintf(printer,"\nNEGATIVE V: item %d cond %d region %d",sptrptr,cptrptr,region);
		}
	else if(chatter && ik == 0)
		fprintf(printer,"\nShort time, cond %d item %d RT %d",cptrptr,sptrptr,temptime);
	if(debug EQ 2)
		{
		printf("\nGOT FIX: REGION = %d fix = %d NS = %d V = %d NV = %d",region,fixation,ns,*(V+ti2),*(NV+ti2));
		}
	} /*end tempos within region*/
return(fixation);
}/* end gd_fixes*/


int total_fixes(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int nitot,int nscmax,int icond,int ik,int region_length)
{
ti3 = 3*nitot*nscmax + icond*nitot + ns;
if(temppos >= end_region && temptime > shorttime)
	temp_fixation = endsen;		/* past the region; cut it short */
else if(temppos < start_region && *(NV+ti3) != 0)	/* regress to before region */
	temp_fixation = endsen;
if(temppos >= start_region && temppos < end_region)
	{
	if(temptime <= shorttime)
		shorts[fixation] = 1;
	if(temptime > longtime)			/* time longer than set for */
		{
		longs[fixation] = 1;
		got_fix = 2;		/* set panic flag */
		*(V+ti3)=0;			/* zero out region */
		(*(NV+ti3))=0;
		fixation += endsen;			/* end the search; got_fix == will terminate */
		if(chatter)
			fprintf(printer,"\nLONG:  Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d Reg from %4d to %4d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);
		}
	else if(temptime > shorttime && temptime <= longtime)
		{
		if(temp_fixation != endsen && got_fix != 2)
			got_fix = 1;			/* indicate there was a first pass fix in the region */
		if(got_fix == 1)
			{
			if(mspc)
				temptime = myround(temptime*10,region_length);
			*(V+ti3)+=temptime;
			(*(NV+ti3))++;
			if(*(V+ti3) < 0)
				fprintf(printer,"\nNEGATIVE V: item %d cond %d region %d",sptrptr,cptrptr,region);
			}
		}
	else if(chatter && ik == 0)
		fprintf(printer,"\nShort time, cond %d item %d RT %d",cptrptr,sptrptr,temptime);
	if(debug EQ 2)
		{
		printf("\nGOT FIX: REGION = %d fix = %d NS = %d V = %d NV = %d",region,fixation,ns,*(V+ti2),*(NV+ti2));
		}
	} /*end tempos within region*/
if(temp_fixation == endsen && got_fix != 1) 	/* gone past region w/o fixation */
	fixation = endsen;													/* end it all */
return(fixation);
}/* end total_fixes*/


int cumulate_position(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int ns,int nitot,int icond,int nscmax,int init_temps,int inity,int cum_grain,int poke_anal)
{
int local_sample;
int tempx,tempy,temps;
int nowtime;
int starting_point;
int local_ti3, last_ti3;
local_ti3 = icond*nitot + ns;	/* start at sample=0 * nitot * nscmax */
last_ti3 = local_ti3;
if(temppos >= end_region && temptime > shorttime && got_fix == 0)
	fixation = endsen;		/* past the region; cut it short */
else if(temppos >= start_region && temppos < end_region && got_fix == 0)
	{
	if(temptime <= shorttime)
		shorts[fixation] = 1;
	if(temptime > longtime)			/* time longer than set for */
		{
		longs[fixation] = 1;			/* don't throw out long fixation */
		if(chatter)
			fprintf(printer,"\nLONG:  Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d Reg from %4d to %4d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);
		}
	if(temptime > shorttime)			/* count long fixations */
		{
		got_fix = 1;
/*  poke_anal = 0 for start of region, 1 for first fix */
		if(poke_anal%2)
			starting_point = temppos;
		else
			starting_point = start_region;
		*(TCUMPOS + local_ti3) = temppos-starting_point;
		nowtime = init_temps;
		if(debug == 5)
			{
			printf("\nIn cumulate_position, ns %d, icond %d, starting_point %d\nPress q to quit: ",ns,icond,starting_point);
			if(getchar() == 'q')
				exit(1);
			}
		for(local_sample = 1;local_sample < cum_positions && fixation < endsen;fixation++)
			{
/* peek ahead at next fixation */
			tempx = atoi(tbuff);
			movenextnumber();
			tempy = atoi(tbuff);
			movenextnumber();
			temps = atoi(tbuff);
			movenextnumber();
/*			tempe = atoi(tbuff);*/
			movenextnumber();	
			if(debug == 5)
				printf("\nIn cumpos, last_ti3 %d, temppos %d, last *TCUMPOS %d, nowtime %d starttime %d",last_ti3,temppos,*(TCUMPOS+last_ti3),nowtime,temps);
			do
				{
				last_ti3 = local_ti3;
				local_ti3 += nitot*nscmax;
				if(poke_anal >= 2)		/* noncumulative version */
					*(TCUMPOS + local_ti3) = temppos - starting_point;
				else			/* cumulative version */
					{
					if((*(TCUMPOS + last_ti3)) > temppos-starting_point)		/* didn't move ahead */
						*(TCUMPOS + local_ti3) = (*(TCUMPOS + last_ti3));
					else
						*(TCUMPOS + local_ti3) = temppos-starting_point;
					}
				local_sample++;
				}
			while(((nowtime += cum_grain) < temps) && (local_sample < cum_positions));	/* still in same fixation */
			if(tempy != inity)
				fixation = endsen;	/* set to break when go to next line*/
			temppos = tempx + (tempy-yoffset) * width;		/* get position of current fixation */
			}  /* end for local_sample */
		fixation = endsen;
		} /*end if temptime in boundaries */
	} /*end if tempos within boundaries*/
if(fixation == endsen)
	for(;local_sample<cum_positions;local_sample++)	/* fill out rest of line */
		{
		local_ti3 += nitot*nscmax;
		*(TCUMPOS + local_ti3) = -997;		/* fill with dummy fake */
		}
return(fixation);
} /* end cumulate_position*/




int go_past(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int poke_anal,int region_length)
{
if(temppos >= start_region && temppos < end_region)
	got_fix = 1;
if(temppos >= end_region && temptime > shorttime)
	fixation = endsen;		/* past the region; cut it short */
else if(got_fix == 1)
	if((poke_anal == 1 && temppos < end_region) || (poke_anal == 2 && temppos >= start_region && temppos < end_region) || (poke_anal == 3 && temppos < start_region))
	{
	if(temptime > longtime)		/* in go_past, ELIMINATE trials with long fixations */
		{
		longs[fixation] = 1;
		if(chatter)			/* time longer than set for */
			fprintf(printer,"\nLONG:  Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d Reg from %4d to %4d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);
		fixation=endsen;
		*(V+ti2)=0;
		(*(NV+ti2))=0;
		return(fixation);
		}
	if(temptime <= shorttime)
		{
		shorts[fixation] = 1;
		if(chatter)
			fprintf(printer,"\nSHORT: Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d Reg from %4d to %4d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);
		}
/*	if(temptime > shorttime && temptime <= longtime)*/
	if(temptime > shorttime)
		{
		if(mspc)
			temptime = myround(temptime*10,region_length);
		*(V+ti2)+=temptime;
		(*(NV+ti2))++;
		if(*(V+ti2) < 0)
			fprintf(printer,"\nNEGATIVE V: item %d cond %d region %d",sptrptr,cptrptr,region);
		}
	if(debug EQ 2)
		{
		printf("\nGOT FIX: REGION = %d fix = %d NS = %d V = %d NV = %d",region,fixation,ns,*(V+ti2),*(NV+ti2));
		}
	}/* end if((poke_anal == 1 && temppos < end_region) || (poke_anal == 2 && temppos >= start_region && temppos < end_region) || (poke_anal == 3 && temppos <= start_region))*/
if(got_fix && poke_anal == 3 && *(NV+ti2) == 0)
	*(NV+ti2) = 1;			/* count zero time before only when fix in region */
return(fixation);
} /*end go_past*/


void write_matrix(int ncmin,int ncmax,int nctot,int nregmax)
{
int j,k,l,jc;
for(j=0,jc=ncmin-1;jc<ncmax;j++,jc++)
	{
	fprintf(printer,"\nCOND %5d                   TO\nFROM\n     ",jc+1);	/* subject and condition number */
	for(l=0;l<nregmax;l++)
		fprintf(printer,"%5d",l+1);
	fprintf(printer,"\n");
	for(k=0;k<nregmax;k++)	/* FROM region */
		{
		fprintf(printer,"%5d",k+1);
		for(l=0;l<nregmax;l++)	/* TO region */
			{
			ti1 = k*nregmax*nctot + l*nctot + j;
			fprintf(printer,"%5d",(*(CUM_MATRIX+ti1)));
			}
		fprintf(printer,"\n");
		}
	}
}/*end write_matrix*/




int land_pos(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int poke_anal,int StartPrevFix,int EndPrevFix)
{
int chars_back;
int ii,tempx,tempy,temps,tempe,lastpos,lasttime;
if(temppos >= end_region && temptime > shorttime)
	fixation = endsen+1;		/* past the region; cut it short */
if(temppos >= start_region && temppos < end_region && fixation < endsen+1)
	{
	if(temptime > longtime)		/* discard trials with long fixations */
		{
		longs[fixation] = 1;
		fixation = endsen;
		if(chatter)			/* time longer than set for */
			fprintf(printer,"\nLONG:  Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d Reg from %4d to %4d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);
		*(V+ti2)=0;
		(*(NV+ti2))=0;
		}
	if(temptime <= shorttime)		/* skip short fixations */
		shorts[fixation] = 1;
	if(temptime > shorttime && temptime <= longtime && (poke_anal == 1 || poke_anal == 3))
		{
		if(*(NV+ti2) == 0)		/* first fix only */
			{
			if(poke_anal == 3 && start_region > 0)			/* launch site except first region */
				{
				for(ii=8;ii>0;ii--)
				movebacknumber();
				tempx = atoi(tbuff);
				movenextnumber();
				tempy = atoi(tbuff);
				movenextnumber();
				temps = atoi(tbuff);
				movenextnumber();
				tempe = atoi(tbuff);
				for(ii=5;ii>0;ii--)
					movenextnumber();
				lasttime = tempe-temps;
				if(tempy >= max_y)			/* outside region */
					{
					if(chatter)
						{
						printf("\ntempy too large, %d, region %d fix %d item %d",tempy,region,fixation,ns);
						fixation = endsen;
						}
					}
				else if(lasttime < shorttime || lasttime >= longtime)
					{
					if(chatter)
						fprintf(printer,"\nLaunch fixation time %d; outside range, discard, region %d, fix %d, item %d",lasttime,region,fixation,ns);
					fixation = endsen;
					}
				else
					{
					lastpos = tempx + (tempy-yoffset) * width;
					chars_back = (start_region - lastpos) * 10;
					while(chars_back >= 800)
						chars_back -= 800;
					if(chars_back <= 0)
						{
						fprintf(printer,"\nCAUTION: chars_back < 0: chars_back %d item %d cond %d region %d\n     fixation %d tempx %d tempy %d lastpos %d temppos %d",chars_back/10,sptrptr,cptrptr,region,fixation,tempx,tempy,lastpos,temppos);
						chars_back = 0;
						}		
					*(V+ti2)=chars_back;
					(*(NV+ti2))++;
					}
				}
			else if(poke_anal == 1)
				{
				if(StartPrevFix == 0 || PrevFixOK(start_region,shorttime,StartPrevFix,EndPrevFix,longtime) != 0)
					{
					*(V+ti2)=(temppos-start_region) * 10;
					(*(NV+ti2))++;
					}
				}
			fixation = endsen;	/* cut the loop short */
			}
		else
			fixation = endsen;
		}
	else if(temptime > shorttime && temptime <= longtime && poke_anal == 2)
		/* get position of second fixation in word */
		{
		if(StartPrevFix == 0 || PrevFixOK(start_region,shorttime,StartPrevFix,EndPrevFix,longtime) != 0)
			{
			if(*(NV+ti2) == 0)		/* first fix  */
				*(NV+ti2) = 9999;
			else if(*(NV+ti2) == 9999)		/* got second fixation */
				{
				*(V+ti2)=(temppos-start_region) * 10;
				(*(NV+ti2)) = 1;
				fixation = endsen;	/* cut the loop short */
				}
			if(*(V+ti2) < 0)
				fprintf(printer,"\nNEGATIVE V: item %d cond %d region %d",sptrptr,cptrptr,region);
			}
		}
	else if(temptime <= shorttime && chatter)
		fprintf(printer,"\nSHORT: Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d Reg from %4d to %4d",cptrptr,sptrptr,fixation,temppos,temptime,start_region,end_region);
	if(debug EQ 2)
		{
		printf("\nGOT FIX: REGION = %d fix = %d NS = %d V = %d NV = %d",region,fixation,ns,*(V+ti2),*(NV+ti2));
		}
	} /* end temppos in region*/
if(fixation == endsen+1)
	fixation = endsen;
if(fixation == endsen && *(NV+ti2) == 9999)
	*(NV+ti2) = 0;
return(fixation);
}/*end landpos*/


int next_fix(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int cptrptr,int sptrptr,int region,int ns,int nitot,int nscmax,int icond,int ik,int poke_anal,int region_length)
{
static int lastpos;
static int two_fix;
ti3 = 3*nitot*nscmax + icond*nitot + ns;
if(fixation == 0)
	two_fix = 0;
if(temppos >= end_region && temptime > shorttime)
	{
	if(got_fix == 1 && (poke_anal%2 == 0 || fixation < endsen -1) && temptime <= longtime)	/* THE fixation */
		{
		if((poke_anal/2) %2 == 0)
			{
			if(mspc)
				temptime = myround(temptime*10,region_length);
			*(V+ti3)+=temptime;
			(*(NV+ti3)) = 1;
			if(*(V+ti3) < 0)
				fprintf(printer,"\nNEGATIVE V: item %d cond %d region %d",sptrptr,cptrptr,region);
			}
		else
			{
			*(V+ti3) = (temppos - lastpos)*10;
			(*(NV+ti3)) = 1;
			}
		if(debug EQ 2)
			{
			printf("\nGOT FIX AFTER REGION %d fix = %d NS = %d V = %d NV = %d",region,fixation,ns,*(V+ti3),*(NV+ti3));
			printf("\n  temptime %d temppos %d lastpos %d",temptime,temppos,lastpos);
			}
		}
	fixation = endsen;		/* past the region; cut it short */
	}
else if(temppos < start_region)	/* regress to before region */
	{
	if(got_fix == 1)	/* THE fixation */
		{
		fixation = endsen;				/* set up to end trial after regression out of region */
		if(temptime <= longtime)
			if((poke_anal/4)%2 != 0)	/* yes, permit regressions, */
				{
				if((poke_anal/2) %2 == 0)		/* duration */
					{
					if(mspc)
						temptime = myround(temptime*10,region_length);
					*(V+ti3)+=temptime;
					(*(NV+ti3)) = 1;
					if(*(V+ti3) < 0)
						fprintf(printer,"\nNEGATIVE V: item %d cond %d region %d",sptrptr,cptrptr,region);
					}
				else						/* saccade length */
					{
					*(V+ti3) = (lastpos - temppos);
					(*(NV+ti3)) = 1;
					}
				}
		}/*end if got_fix == 1*/
	} /*end if temppos < start_region*/
else if(temppos >= start_region && temppos < end_region)
	{
	if(temptime > longtime && chatter && ik == 0)			/* time longer than set for */
		fprintf(printer,"\nLong time, cond %d item %d RT %d",cptrptr,sptrptr,temptime);
	else if(temptime > shorttime && temptime <= longtime)
		{
		if(got_fix == 1 && poke_anal > 8)
			{
			two_fix = 1;
			got_fix = 0;
			}
		else if(two_fix == 0)
			{
			got_fix = 1;			/* indicate there was a fix in the region */
			lastpos = temppos;		/* record last position */
			}
		}
	else if(chatter && ik == 0)
		fprintf(printer,"\nShort time, cond %d item %d RT %d",cptrptr,sptrptr,temptime);
	if(debug EQ 2)
		{
		printf("\nGOT FIX IN REGION %d fix = %d NS = %d",region,fixation,ns);
		printf("\n  temptime %d temppos %d lastpos %d",temptime,temppos,lastpos);
		}
	} /*end if temppos within region*/
return(fixation);
} /*end next_fix*/


int inhreturn(int ns,int fixation,int temppos,int temptime,int endsen,int shorttime,int longtime,int cptrptr,int sptrptr,int nitem,int ncmin,int nscmax,int nregion,int icond,int nitot)
{
static int iflag;
int fix_pos;
int i;
int region,curr_cond;
int start_region,end_region;
int ObservationType;
int prev_position;

/* put something in to take care of short and long fixations */

if(fixation == 0)
	iflag = 0;
if(temptime > shorttime && temptime <= longtime)
	{
	if(debug == 2)
		printf(": nregion %d temptime %d temppos %d cptrptr %d ncmin %d",nregion,temptime,temppos,cptrptr,ncmin);
/* identify the region of this fixation */
	for(region=0,fix_pos = 9999;region<nregion && fix_pos == 9999;region++)
		{
		ti2 = region * nitot *nscmax + icond*nitot + nitem;
		if(region == 0)
			start_region = 0;
		else
			start_region = *(C+ti2);
		if(region == nregion-1)		/* last region */
			{
			end_region = start_region + 20;	/* fake */
			if(end_region/width > start_region/width)	/* went around end */
				end_region = (start_region/width) * width + width-1;
						/* set end_region to end of line */
			}
		else
			end_region = *(C+ti2+nitot*nscmax);
		if(debug == 2)
			printf("\n   identified region %d, start_region %d end_region %d fix_pos %d",region,start_region,end_region,fix_pos);
		if(temppos >= start_region && temppos < end_region)
			fix_pos = region;
	if(debug == 2)
		printf("\nEnd of region loop, region %d start_region %d end_region %d",region,start_region,end_region);
		} /*end for region; it's identified the region!!!*/

	for(i = 3; i > 0;i--)		/* irn[0] is current, irn[1] is n-1, irn[2] is n-2 */
/* and in new code, irn[3] is n-3 */
		{
		irn[i].fixation = irn[i-1].fixation;
		irn[i].position = irn[i-1].position;
		irn[i].region = irn[i-1].region;
		irn[i].duration = irn[i-1].duration;
		}
	irn[0].fixation=fixation;
	irn[0].position = temppos;
	irn[0].region = fix_pos;
	irn[0].duration = temptime;
/*	if(fix_pos == nregion-1)*/
	if(fix_pos == nregion-2)				/* don't count fixations in last true region
																	i.e. region before fake 20 chars; you should
																	put a ^ (caret!) at the end of the sentence 
																	to create this fake region */
		return(endsen);
	if(fix_pos == 0 || fixation < 2)
		return(fixation);		/* ignore fixations in first and last regions and first 2 fixations */
	if(fix_pos == irn[1].region)
		return(fixation);		/* return when get multiple fixations in one region */
/* got a good one; types 1 and 2 = regression > 3 characters */
/* and count only forward saccades after legal regressions */

/* OLD CODE */
/*	if(irn[0].region == (irn[1].region)-1 && irn[2].region == irn[0].region && irn[0].position <= (irn[1].position) -3 && irn[0].position > irn[1].position -15)
		ObservationType = 1;	
	else if(irn[0].region == (irn[1].region)-1 && irn[2].region == (irn[0].region)-1 && irn[0].position <= (irn[1].position) -3 && irn[0].position > irn[1].position -15)
		ObservationType = 2;	
	else if(irn[0].region == (irn[1].region)+1 && irn[2].region == (irn[1].region)+1 && iflag == 1)
		ObservationType = 3;	
	else if(irn[0].region == (irn[1].region)+2 && irn[2].region == (irn[1].region) + 1 && iflag == 1)
		ObservationType = 4;	
	else
		ObservationType = 0;
*/


/* NEW CODE */
	if(irn[0].region < irn[1].region && irn[0].position <= (irn[1].position)-3 && irn[0].position > irn[1].position-15 && last_three(&prev_position))
		ObservationType = 1;		/* reg in prev fixed region */
	else if(irn[0].region < irn[1].region && irn[0].position <= (irn[1].position) -3 && irn[0].position > irn[1].position -15 && !last_three(&prev_position))
		ObservationType = 2;		/* reg into nonfixed region */
	else if(irn[0].region > irn[1].region && irn[0].position >= irn[1].position+3 && irn[0].position < irn[1].position+15 && last_three(&prev_position) && iflag == 1)
		ObservationType = 3;		/* forward saccade into prev fixed region */
	else if(irn[0].region > irn[1].region && irn[0].position >= (irn[1].position)+3 && irn[0].position < irn[1].position+15 && !last_three(&prev_position) && iflag == 1)
		ObservationType = 4;		/* forward saccade nonfixed region */
	else
		ObservationType = 0;


	if(debug == 2)
		printf("\nObservationType %d",ObservationType);

	if(ObservationType == 0)
		iflag = 0;
	else
		{
		if(ObservationType < 3)
			iflag = 1;
		else
			iflag = 2;
		if(debug == 2)
			printf("\n%d\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t %d",ns,sptrptr,cptrptr,ObservationType,irn[1].duration,irn[1].position,irn[1].region,irn[0].duration,irn[0].position,irn[0].region,abs(irn[0].position-irn[1].position));
/* added 7/29/02, print out absolute size of saccade preceding return/nonreturn saccade */
/* added 8/6/02, print out discrepancyin landing positions */
		fprintf(Subfile,"\n%d\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t %d\t %d",ns+1,sptrptr,cptrptr,ObservationType,(irn[1].region)+1,irn[1].position,irn[1].duration,(irn[0].region)+1,irn[0].position,irn[0].duration,abs(irn[0].position-irn[1].position),irn[2].duration,abs(irn[1].position-irn[2].position),abs(irn[0].position-prev_position));
		}
/*	if(iflag == 2)
		return(endsen);
	else*/
		return(fixation);
	}
	return(fixation);
}


/* new function to check whether region was fixated in preceding two fixations */

int last_three(int *prev_position)
{
if(irn[0].region == irn[2].region || irn[0].region == irn[3].region)
	{
	if(irn[0].region == irn[2].region)
		*prev_position =irn[2].position;
	else
		*prev_position = irn[3].position;
	return(1);
	}
else
	{
	*prev_position = irn[0].position;
	return(0);
	}
}




int fill_matrix(int fixation,int temppos,int temptime,int shorttime,int longtime,int cptrptr,int sptrptr,int nregion,int nregmax,int ncmin,int nctot,int nitot,int nscmax,int nitem,int icond,int around_end)
{
int region,ik,curr_cond;
int start_region,end_region;
int fix_pos;
static int last_pos,far_fix;
if(temptime > longtime)
	longs[fixation] = 1;
if(temptime <= shorttime)
	shorts[fixation] = 1;
if(fixation == 0)
	far_fix = 0;
if(temptime > longtime && chatter)			/* time longer than set for */
	fprintf(printer,"\nLONG:  Cnd %3d Itm %3d Fix %3d Pos %3d Time %5d",cptrptr,sptrptr,fixation,temppos,temptime);
else if(temptime > shorttime && temptime <= longtime)
	{
	if(debug == 2)
		printf("IN fill_matrix(), nregion %d temptime %d temppos %d cptrptr %d ncmin %d",nregion,temptime,temppos,cptrptr,ncmin);
	for(region=0,fix_pos = 9999;region<nregion && fix_pos == 9999;region++)
		{
		ti2 = region * nitot *nscmax + icond*nitot + nitem;
		if(region == 0)
			start_region = 0;
		else
			start_region = *(C+ti2);
		if(region == nregion-1)		/* last region */
			{
			end_region = start_region + 20;	/* fake */
			if(end_region/width > start_region/width)	/* went around end */
				end_region = (start_region/width) * width + width-1;
						/* set end_region to end of line */
			}
		else
			{
			end_region = *(C+ti2+nitot*nscmax);
			}	
		if(!around_end)		/* don't allow regions to wrap around end of line? */
			if(start_region/width < end_region/width)	/* went around end */
				start_region = ((start_region/width)+1) * width;	/* start of line */
		if(debug == 2)
			printf("\n  checking: start_region %d end_region %d fix_pos %d last_pos %d",start_region,end_region,fix_pos,last_pos);
		if(temppos >= start_region && temppos < end_region)
			{
			fix_pos = region;
			}
		} /*end for region*/
	if(fixation == 0 || (which_matrix == 2 && last_pos < far_fix))		/* filter out saccades from regressions */
		{
		last_pos = fix_pos;
		}
	else
		{
		curr_cond = cptrptr - ncmin;
		ti2 = last_pos*nregmax*nctot + fix_pos*nctot + curr_cond;
		(*(CUM_MATRIX+ti2))++;
		(*(S_MATRIX+ti2))++;
		ti2 = last_pos*nregmax*nscmax*nitot + fix_pos*nscmax*nitot + curr_cond%nscmax*nitot + nitem;
		(*(I_MATRIX+ti2))++;
		last_pos = fix_pos;
		}
	if(fix_pos > far_fix)
		far_fix = fix_pos;

	if(debug == 2)
		printf("\nlast_pos %d fix_pos %d far_fix %d curr_cond %d",last_pos,fix_pos,far_fix,curr_cond);
	}/*end temptime in boundaries*/
return(fixation);
} /*end fill_matrix*/

/********************************/

int region_vector(int fixation,int temppos,int temps,int tempe,int temptime,int endsen,int start_region,int end_region,int shorttime,int cptrptr,int sptrptr,int region,int ns,int ik,int* GotFix,int FP_only)
	{
	static int lasttempe;
/*printf("\nIn region_vector,region %d fix %d GotFix %d temps %d tempe %d lasttempe %d",region,fixation,*GotFix,temps,tempe,lasttempe);*/
	if(temptime > shorttime)
		{
		if(*GotFix == 0)
			{
			if(temppos >= start_region && temppos < end_region)
				{
/*printf("\nentering region %d start_region %d end_region %d temps %d",region,start_region,end_region,temps);
if(getchar() == 'q')
	exit(1);*/
				fprintf(Allfile,"%d ",temps);
				*GotFix = 1;
				}
			else if (FP_only == 1 && temppos >= end_region)			/* set as poke_anal */
				{
				fprintf(Allfile,"0 0 ");
				fixation = endsen;
				}			/* keep this in if you want first pass fixations */
			else if (FP_only == 0 && fixation == endsen-1)
					{
					fprintf(Allfile,"0 0 ");
					}
			}
		else if(*GotFix == 1)
			{
			if(temppos < start_region || temppos >= end_region)
				{
/*printf("\nleaving region %d start_region %d end_region %d tempe %d lasttempe %d",region,start_region,end_region,tempe,lasttempe);
if(getchar() == 'q')
	exit(1);*/

				fprintf(Allfile,"%d ",lasttempe);
				*GotFix = 2;
				fixation = endsen;
				}
			}
	lasttempe = tempe;
		}
	else if(chatter && ik == 0)
		fprintf(printer,"\nShort time, cond %d item %d RT %d",cptrptr,sptrptr,temptime);
	if(debug EQ 2)
		{
		printf("\nGOT FIX: REGION = %d fix = %d NS = %d V = %d NV = %d",region,fixation,ns,*(V+ti2),*(NV+ti2));
		}
	if(*GotFix == 1 && fixation == endsen)
			fprintf(Allfile," 0");
	return(fixation);
	}/* end region_vector*/
	



char *tgets(char *buff,FILE *stream)
	{
	int i;
	fgets(buff,MAXLINE,stream);
	for(i=0;buff[i] != '\n' && i < MAXLINE;i++)
		;
	buff[i] = '\0';
	return(buff);
	}


int correct(int *debug,int *qskip,int *lookahead,int *minq,int *maxq,int *nimin,int *nimax,int *nregmax,int *ncmin,int *ncmax,int *nscmax,int *cpos,int *ipos,int *npos,int *dpos,int *longtime,int *shorttime,int *nitot,int *nctot,int *qcpos,int *qresppos,int *width,int *max_y,int *around_end,int *double_space,int *first_seq,int *last_seq)
{
int i,j,k;
static int changes = 0;
printf("\n Type a number to change a control parameter, or CR to quit.");
printf("\n0: debug level        =      %d",*debug);
printf("\n  qskip = 2 means that questions have same conditions as items");
printf("\n  lookahead = 1 means that you are eliminating on basis of errors\n  in which case min and max question to examine must be set to nonzero");
printf("\n1: qskip              =       %d     2: lookahead          =     %d",*qskip,*lookahead);
printf("\n3: min ques           =       %d     4: max ques           =     %d",*minq,*maxq);
printf("\n5: smallest item      =       %d     6: largest item       =     %d",*nimin,*nimax);
printf("\n7: maximum regions    =       %d",*nregmax);
printf("\n8: smallest condition =       %d     9: largest condition  =     %d",*ncmin,*ncmax);
printf("\n10: number of subconds=       %d",*nscmax);
printf("\n11: position of cond #=       %d    12: position of item # =     %d",*cpos,*ipos);
printf("\n13: position of #fix  =       %d    14: data start position=     %d",*npos,*dpos);
printf("\n15: longcutoff        =       %d  16: shorttime          =     %d",*longtime,*shorttime);
printf("\n  (next 2 zero unless rejecting on basis of questions)");
printf("\n17: pos. of ques #    =       %d    18: pos. of ques resp  =     %d",*qcpos,*qresppos);
printf("\n19: screen width (char)=      %d",*width);
printf("\n20: max lines of text =       %d",*max_y);
printf("\n21: region wrap around end? 0 = no, 1 = y;      %d   ---  ?",*around_end);
printf("\n22: double_space? 0 = no, 1 = y;      %d",*double_space);
printf("\nanalyze part: 24: first_seq = %d    24: last_seq           =     %d",*first_seq,*last_seq);
printf("\n25: max trials in condition = %d  ---  ? ",max_in_cond);
gets(buff);
if(strlen(buff) == 0)
	{
	fprintf(printer,"\n0: debug level   =       %d",*debug);
	fprintf(printer,"\t\t1  qskip   =       %d",*qskip);
	fprintf(printer,"\n   (iff qskip = 1, interpret lookahead as corr. resp. to question");
	fprintf(printer,"\n   and if lookahead is nonzero, make the following 2 values nonzero)");
	fprintf(printer,"\n2:   lookahead        =       %d",*lookahead);
	fprintf(printer,"\n3:   minimum question =       %d",*minq);
	fprintf(printer,"\n4:   maximum question =       %d",*maxq);
	fprintf(printer,"\n5: smallest item      =       %d",*nimin);
	fprintf(printer,"\n6: largest item       =       %d",*nimax);
	fprintf(printer,"\n7: maximum regions    =       %d",*nregmax);
	fprintf(printer,"\n8: smallest condition =       %d",*ncmin);
	fprintf(printer,"\n9: largest condition  =       %d",*ncmax);
	fprintf(printer,"\n10: number of subconds=       %d",*nscmax);
	fprintf(printer,"\n11:position of cond # =       %d",*cpos);
	fprintf(printer,"\n12:position of item # =       %d",*ipos);
	fprintf(printer,"\n13:position of #fix   =       %d",*npos);
	fprintf(printer,"\n14:data start position=       %d",*dpos);
	fprintf(printer,"\n15:longcutoff         =       %d",*longtime);
	fprintf(printer,"\n16:shorttime          =       %d",*shorttime);
	fprintf(printer,"\n  (next 2 zero unless rejecting on basis of questions)");
	fprintf(printer,"\n17:  pos. of ques #   =       %d",*qcpos);
	fprintf(printer,"\n18:  pos. of ques resp=       %d",*qresppos);
	fprintf(printer,"\n19:screen width (char)=       %d",*width);
	fprintf(printer,"\n20:max lines of text  =       %d",*max_y);
	fprintf(printer,"\n21: region wrap around end? 0 = no, 1 = yes:   %d\n",*around_end);
	fprintf(printer,"\n22: doublespace? 0 = no, 1 = yes:   %d\n",*double_space);
	fprintf(printer,"\n23: first_seq         =       %d",*first_seq);
	fprintf(printer,"\n24: last_seq         =        %d",*last_seq);
	fprintf(printer,"\n25: max_in_cond   =           %d",max_in_cond);
	
	if(changes)
		return(-1);
	else
		return(0);
	}

changes = 1;
i = atoi(buff);
printf("\nNew value? ");
j = atoi(gets(buff));
switch(i)
	{
	case 0:
		*debug = j;
		break;
	case 1:
		*qskip = j;
		break;
	case 2:
		*lookahead = j;
		break;
	case 3:
		*minq = j;
		break;
	case 4:
		*maxq = j;
		break;
	case 5:
		*nimin = j;
		*nitot = *nimax-*nimin+1;
		break;
	case 6:
		*nimax = j;
		*nitot = *nimax-*nimin+1;
		break;
	case 7:
		*nregmax = j;
		break;
	case 8:
		*ncmin = j;
		*nctot = *ncmax-*ncmin+1;
		break;
	case 9:
		*ncmax = j;
		*nctot = *ncmax-*ncmin+1;
		break;
	case 10:
		*nscmax = j;
		break;
	case 11:
		*cpos = j;
		break;
	case 12:
		*ipos = j;
		break;
	case 13:
		*npos = j;
		break;
	case 14:
		*dpos = j;
		break;
	case 15:
		*longtime = j;
		break;
	case 16:
		*shorttime = j;
		break;
	case 17:
		*qcpos = j;
		break;
	case 18:
		*qresppos = j;
		break;
	case 19:
		*width = j;
		break;
	case 20:
		*max_y = j;
		break;
	case 21:
		*around_end = j;
		if(*around_end == 1)
			{
			printf("\nWARNING: ms/char and dev from predicted will be wrong!\nPress any key to continue. \n");
			getchar();
			}
		break;
	case 22:
		*double_space = j;
		break;
	case 23:
		*first_seq = j;
		break;
	case 24:
		*last_seq = j;
		break;
	case 25:
		max_in_cond = j;
		break;
	}

return(changes);        /* ok, normal return */
} /*end correct*/


int myround(int total,int count)
{
if((float)(total%count) >= ((float)(count))/2)
	return(total/count + 1);
else
	return(total/count);
}


int get_regression(int nimin,int nimax,int ncmin,int ncmax,int nscmax,int qskip,int cpos,int ipos,int npos,int dpos,int longtime,int shorttime,int nitot, int i, int *past_region, int *in_region, int poke_anal,int around_end,int double_space)
{
FILE *corrbuff;
FILE *gdbuff;
char *ttbuff;
int fpt,lpt,tix;
int endsen, cnt, icond, ns,number_fixations;
int phrlen,rt;
double dphrlen,drt,sumx,sumy,sumxy,sumx2,sumy2,fn,ftemptime;
double varx, vary, numer,denom, corret;
int fix_count;
int ci;
int temp;
double ftemp;
int qcond,qresp;
char qbuff[MAXLINEX];
char tempname[80];
int skippos;
int nchar,n;
int nregion,region,ik,start_record,fixation;
int tempx,tempy,temps,tempe,temppos,temptime;
int start_region,end_region,region_length;
int cptrptr, sptrptr;
int temp_first_region_for_regression;

/* make filename */
strcpy(tempname,file);
for(ci=0;tempname[ci] != '.';ci++)
	;
if(anal == 2 || anal == 10)
	{
	tempname[++ci]='f';
	tempname[++ci]='p';
	tempname[++ci]='c';
	tempname[++ci]='\0';
	}
else if(anal == 3)
	{
	tempname[++ci]='t';
	tempname[++ci]='t';
	tempname[++ci]='c';
	tempname[++ci]='\0';
	}
else if (anal == 8)
	{
	if (poke_anal == 1)
		tempname[++ci]='1';
	else
		tempname[++ci] = '2';
	tempname[++ci]='s';
	tempname[++ci]='c';
	}

if((corrbuff = fopen(tempname,"r")) != NULL)
	{
	if(i == 0)                      /* first subject */
		{
		fscanf(corrbuff,"%lf%lf%lf%d%d%d%d%d",&alpha,&beta,&corret,&nimin,&nimax,&ncmin,&ncmax,&temp_first_region_for_regression);
		if(temp_first_region_for_regression != first_region_for_regression && alpha != 0.0 && beta != 0.0)
			{
			printf("\nFirst region for regression in file differs from that requested (it is %d).",temp_first_region_for_regression);
			printf("\nType 'y' to indicate it's ok, 'n' to start over.");
			gets(tempname);
			if(tolower(tempname[0]) != 'y')
				{
				fclose(corrbuff);
				return(0);
				}
			first_region_for_regression = temp_first_region_for_regression;
			}
		printf("\n\nHere are the sources of the regression parameters being used.\nIf you don't like them, control-c out and erase\nthe correlation files.");
		printf("\nnimin %d nimax %d ncmin %d ncmax %d first region %d",nimin,nimax,ncmin,ncmax,first_region_for_regression);
		fprintf(printer,"\nRegression source: nimin %d nimax %d ncmin %d ncmax %d first region %d\n",nimin,nimax,ncmin,ncmax,first_region_for_regression);
		fclose(corrbuff);
		if(alpha != 0.0 || beta!= 0.0)
			return(1);
		} /*end i == 0*/
	else
		{ /*not the first subject*/
		fscanf(corrbuff,"%lf%lf%lf",&alpha,&beta,&corret);      /* .cor file has alpha, beta, correlation */
	/*printf("\nalpha %f beta %f corret %f nimin %d",alpha,beta,corret,nimin);*/
		fclose(corrbuff);                                       /* then min and max items and conds */
		/* info to trace file/printout*/
		fprintf(printer,"\nalpha: %f beta: %f corret: %f nimin: %d nimax: %d ncmin: %d ncmax: %d first_region_for_regression: %d",alpha,beta,corret,nimin,nimax,ncmin,ncmax,first_region_for_regression);

		if(alpha != 0.0 || beta != 0.0)
			return(1);
		}/*end not first subject*/
	}/* end if((corrbuff = fopen(tempname,"r")) != NULL)*/
n = 0;
sumx=sumy=sumxy=sumx2=sumy2=0.0;
if((corrbuff = fopen(tempname,"w")) == NULL)
	openfail(tempname);
if((gdbuff=fopen(file,"r")) EQ NULL)
	openfail(file);

while(fgets(buff,MAXLINEX,gdbuff) != NULL)      /* keep going until EOF */
	{
	cptrptr = atoi(buff+spacebuff(buff,cpos));
	sptrptr = atoi(buff+spacebuff(buff,ipos));
	number_fixations = atoi(buff+spacebuff(buff,npos));
	if(number_fixations > total_samples)
		{
		printf("\nWARNING REGRESSION: %d fixations on trial %d for subject ?",number_fixations,sptrptr);
		fprintf(printer,"WARNING REGR!!!: %d fixations on trial %d for subject ?\n",number_fixations,sptrptr);
		}
	ns = sptrptr-nimin;
	if(exceptflag)
		{
		if(vexcept[ns] == 99)
			cptrptr = ncmax+1;              /* discard item */
		else
			cptrptr += vexcept[ns]; /* adjust condition */
		}
	if(debug EQ 2)
		printf("\n\b ****SENTENCE**** %d, cond %d ",sptrptr,cptrptr);


	/* skip junk sentence plus question if needed */
	if(cptrptr < ncmin || cptrptr > ncmax || sptrptr > nimax || sptrptr<nimin)
		{
		if(debug EQ 2)
			printf("\nIN REGR skipping junk sen # %d, cond # %d",sptrptr,cptrptr);
		if(qskip == 2)		/* questions with same cond number */
			if(fgets(buff,MAXLINEX,gdbuff) == NULL)
				{
				printf("\nEnd of file after item number %d, looking for question",sptrptr);
				fclose(gdbuff);
				return(1);
				}
		} /*end skip junk sentence*/
	else
		{  /*good sentence*/
		endsen = atoi(buff+spacebuff(buff,npos));
		tbuff = buff+spacebuff(buff,dpos);
		ttbuff = tbuff;
		if(debug EQ 2)
			{
			printf("\nREGR: SPTRPTR = %d",sptrptr);
			printf("\nCPTRPTR = %d",cptrptr);
			printf("\nENDSEN  = %d",endsen);
			}
		for(icond=0;icond<nscmax;icond++)       /* find match to cond # */
			{
			ti1 = icond * nitot + ns;
			if(debug >= 2)
				printf("\nREGR  icond %d *(C+ti1) %d cptrptr %d",icond,*(C+ti1),cptrptr);
			if(*(C+ti1) EQ cptrptr)
				break;
			}
		if(debug >= 2)
			printf("\nREGR Found condition match: icond = %d cptrptr = %d ti1 = %d",icond,cptrptr,ti1);
		if(icond EQ nscmax)
			{
			printf("\nIN REGR: SCREWUP! sen %d cond %d",sptrptr,cptrptr);
			exit(1);
			}
		if(debug EQ 2)
			printf("\n    NS = %d, adjusted cond = %d",ns,cptrptr);
		ti1 = icond*nitot + ns;
		*(ITEMCOND+ti1) = cptrptr; /* cond no for this subj,this sent */
		nregion = *(NR+ti1);
		if(debug == 2)
			printf("\nREGR Going to region x fixation scan, %d regions",nregion);
		for(region=first_region_for_regression-1,got_fix = 0;region < nregion-1; region++)
			{
			ftemptime = 0.0;
			fix_count = 0;
			*in_region = *past_region = FALSE;

			if(debug == 2)
				printf("\n  Examining region %d",region);
			ti2 = region*nitot*nscmax + icond*nitot + ns;
			if(region == 0)
				start_region = 0;
			else
				start_region = *(C+ti2);
			if(region == nregion-1)		/* last region SHOULD NEVER HAPPEN*/
				{
				end_region = start_region + 20;	/* fake */
				if(end_region/width > start_region/width)	/* went around end */
					end_region = (start_region/width) * width + width-1;
								/* set end_region to end of line */
				}
			else
				end_region = *(C+ti2+nitot*nscmax);

			region_length = end_region - start_region;
			if(!around_end)		/* don't allow regions to wrap around end of line? */
				if(start_region/width < end_region/width || region_length > width)	/* went around end */
					start_region = (end_region/width) * width;	/* start of current line */
			if(double_space)
				while(region_length > width)
					region_length -= width;			/* get rid of skipped lines */

			tbuff = ttbuff;                         /* set or reset buffpointer */
			for(fixation=0,start_record=FALSE;fixation < endsen; fixation++)
				{
				if(debug == 2)
					printf("\nREGR:  fix %d",fixation);
				tempx = atoi(tbuff);			/* x pos of fix */
				movenextnumber();
				tempy = atoi(tbuff);			/* y pos of fix */
				movenextnumber();
				temps = atoi(tbuff);			/* start fix time */
				movenextnumber();
				tempe = atoi(tbuff);			/* end fix time */
				movenextnumber();
				temppos = tempx + (tempy-yoffset) * width;	/* fixation position */
				temptime = tempe-temps;
				if(!start_record)	/* skip past any bad initial fixations */
					{				
					if(temppos >= -1 && temppos < end_region)
						{
						start_record = TRUE;
						}
					}
				if(start_record && tempy >= 0 && tempy < max_y)	/* discard fixations with negative */
					{					/* or oversized y values as well as bad initial fix */
					if(debug == 2)
						{
						printf("\nREGR: fixation %d start_region %d, end_region %d temppos %d\n   tempx %d tempy %d temps %d tempe %d",fixation,start_region,end_region,temppos, tempx,tempy,temps,tempe);
						}
					if(anal == 2 || anal == 10)     /* first pass or eyegaze */
						fixation = fp_regr(fixation,temppos,temptime,endsen,start_region,end_region,shorttime,longtime,region,ns,&ftemptime,&fix_count);
					else if(anal == 3 || anal == 16)	/* total time or totalgaze */
						fixation = tt_regr(fixation,temppos,temptime,start_region,end_region,shorttime,longtime,region,ns,&ftemptime,&fix_count,endsen);
					else if (anal == 8)
						fixation = sec_pass_regr(fixation,temppos,temptime,start_region,end_region,shorttime,longtime,region,ns,past_region,in_region,poke_anal, &ftemptime, &fix_count,endsen);
					else
						{
						printf("\nTHAT'S NO WAY TO ANALYZE YOUR DATA!");
						exit(1);
						}
					}/* end if(start_record && tempy >= 0 && tempy < max_y)*/
					else if(debug == 2)
						printf("\nReject fixation %d: start_record = %d, tempy = %d",fixation,start_record,tempy);
				}                               /* matched with for(fixation... */

				/* increment parameters for valid info in region*/
				if ( (anal==8) || ( (fix_count != 0)&&( (anal==2)||(anal==3) ) ) )
					{ /*count zero fixations for second pass, not for fp or tt*/
					dphrlen = (double)(region_length);

					if (debug == 2)
						fprintf(printer, "\nGetRegression: region %d time %f length %f",region, ftemptime,dphrlen );

					sumy += ftemptime;
					sumx += dphrlen;
					sumxy += (ftemptime * dphrlen);
					sumy2 += (pow(ftemptime,2.));
					sumx2 += (pow(dphrlen,2.));
					n++;
					} /*incremented*/
			}   /* matched with for(region... */

		if(qskip == 2)          /* question on next line, same cond # */
			if(fgets(buff,MAXLINEX,gdbuff) == NULL)
				{
				printf("\nEnd of file after item number %d, looking for question",sptrptr);
				fclose(gdbuff);
				return(1);
				}
		} /* end good sentence*/
	} /* end while not EOF*/
fclose(gdbuff);

/*print out results*/
/*to screen*/
printf("\n\nn is %d; sumx is %f, sumy is %f; sumxy is %f ", n, sumx, sumy, sumxy);
printf("\nsumx2 is %f; sumy2 is %f", sumx2, sumy2);
fn = (double)(n);
varx = (sumx2 - ((pow(sumx,2.))/fn));	
printf("\nvarx is %f", varx);
vary = (sumy2 - ((pow(sumy,2.))/fn));	
printf("\nvary is %f", vary);
numer = (sumxy - ((sumx * sumy) /fn));  
printf("\nnumer is %f", numer);
denom = (sqrt(varx * vary));
printf("\ndenom is %f", denom);
corret = numer / denom;	
printf("\ncorr is equal to %f", corret);
beta = numer / varx;
alpha = sumy/n - beta*(sumx/fn);
printf("\nbeta = %f, alpha = %f", beta, alpha);
/* to correlation file*/
fprintf(corrbuff,"%f %f %f %d %d %d %d %d\n",alpha,beta,corret,nimin,nimax,ncmin,ncmax,first_region_for_regression);
/* to trace file/printout*/
fprintf(printer,"\nn: %d, sumx: %f, sumy: %f, sumxy: %f, sumx2: %f, sumy2: %f", n, sumx, sumy, sumxy, sumx2, sumy2);
fprintf(printer,"\nalpha: %f beta: %f corret: %f nimin: %d nimax: %d ncmin: %d ncmax: %d first_region_for_regression: %d",alpha,beta,corret,nimin,nimax,ncmin,ncmax,first_region_for_regression);
fclose(corrbuff);
return(1);
} /* end get_regression*/



/* regression calculation for first pass and eventually total time */
int fp_regr(int fixation,int temppos,int temptime,int endsen,int start_region,int end_region,int shorttime,int longtime,int region,int ns,double *ftemptime, int *fix_count)
{
if(temppos >= end_region && temptime > shorttime)
	fixation = endsen;		/* past the region; cut it short */
else if(temppos < start_region && *fix_count != 0)	/* regress to before region */
	fixation = endsen;
else if(temptime > longtime)			/* discard regions with long fixs */
	{
	*ftemptime = 0;
	*fix_count = 0;
	fixation = endsen;
	}
else if(temppos >= start_region && temppos < end_region)
	{
	if(temptime > shorttime)
		{
		*ftemptime += (double)(temptime);
		(*fix_count)++;
		} 
	}
	if(debug EQ 2)
		{
		printf("\nREGR: GOT FIX: REGION = %d fix = %d NS = %d time = %d count = %d",region,fixation,ns,*ftemptime,*fix_count);
		}
return(fixation);
} /*end fp_regr*/


int tt_regr(int fixation,int temppos,int temptime,int start_region,int end_region,int shorttime,int longtime,int region,int ns,double *ftemptime, int *fix_count,int endsen)
{
if(temptime > longtime)			/* discard regions with long fixs */
	{
	*ftemptime = 0;
	*fix_count = 0;
	fixation = endsen;
	}
else if(temppos >= start_region && temppos < end_region)
	{
	if(temptime > shorttime && temptime <= longtime)
		{
		*ftemptime += (double)(temptime);
		(*fix_count)++;
		} 
	}
	if(debug EQ 2)
		{
		printf("\nREGR: GOT FIX: REGION = %d fix = %d NS = %d time = %d count = %d",region,fixation,ns,*ftemptime,*fix_count);
		}
return(fixation);
}/*end tt_regr*/



int sec_pass_regr(int fixation,int temppos,int temptime,int start_region,int end_region,int shorttime,int longtime, int region,int ns,int *past_region,int *in_region,int poke_anal, double *ftemptime, int *fix_count,int endsen)
{
if(temptime > longtime)			/* discard regions with long fixs */
	{
	*ftemptime = 0;
	*fix_count = 0;
	fixation = endsen;
	}
else
	{
	if((*fix_count) == 0)
		*(fix_count) = 1;
	if(temppos >= end_region && temptime > shorttime)
		*past_region = 1;               /* set to true */
	if(poke_anal == 2)              /* including rereading time before go past */
		{
		if(*in_region == 1 && temppos < start_region)
		*past_region = 1;
		if(temppos >= start_region && temppos < end_region && *in_region == 0)
			{
			if(temptime > shorttime && temptime <= longtime)
				*in_region = 1;
			}
		}
/* KLUDGE to set second pass straight and include time in region after
regressing out of it but before going past it */

	if(temppos >= start_region && temppos < end_region && (*past_region) == 1)
		{
		if(temptime > shorttime && temptime <= longtime)
			{
			if(poke_anal == 2)
				*in_region = 1;
			*ftemptime+= (double) temptime;
			(*fix_count)++;
			}
		if(debug EQ 2)
			{
			printf("\nREGR: GOT FIX: REGION = %d fix = %d NS = %d V = %d NV = %d",region,fixation,ns,*ftemptime,*fix_count);
/*		fprintf(printer,"\nSecond_Pass_Regr: region %d time %f",region, *ftemptime);*/
			}
		} /* end if in region*/
	}
return(fixation);
}/*end sec_pass_regr*/



/* returns 1 if previous fixation was in the specified range before
start_region, 0 otherwise */

int PrevFixOK(int start_region, int shorttime,int StartPrevFix,int EndPrevFix,int longtime)
{
int ii;
int tempx,tempy,temps,tempe,lastpos,lasttime;
for(ii=8;ii>0;ii--)
	movebacknumber();
tempx = atoi(tbuff);
movenextnumber();
tempy = atoi(tbuff);
movenextnumber();
temps = atoi(tbuff);
movenextnumber();
tempe = atoi(tbuff);
lastpos = tempx + (tempy-yoffset) * width;
lasttime = tempe-temps;
temp_fixation = lasttime;			/* global variable, cheat record of prev fix */
for(ii=5;ii>0;ii--)
	movenextnumber();

/*printf("\nstart_region %d StartPrevFix %d EndPrevFix %d",start_region,StartPrevFix,EndPrevFix);
printf("\ntempx %d tempy %d temps %d tempe %d lastpos %d lasttime %d",tempx,tempy,temps,tempe,lastpos,lasttime);
getchar();*/

if(StartPrevFix == 0)
	return(1);			/* fake return, for version 5 of first fix */
else if (lastpos >= start_region - StartPrevFix && lastpos <= start_region-EndPrevFix && lasttime > shorttime && lasttime <= longtime && tempy < max_y)
	return (1);
else
	return (0);
}






void compute_lengths(int nitot,int nimin,int ncmin,int nctot,int nregmax)
{
int c,ni,index,region,icond,item;
int tempitem,tempcond,nregion;
int start,end;
start = 0;
ni = 0;
rewind(conbuff);
while((c = fgetc(conbuff)) != EOF)	/* count the lines */
	{
/*	printf("%c",c);*/
	if(c == '\n')
		ni++;
	}
rewind(conbuff);
if(!wide)
	fprintf(Allfile,"item,cond,region,length\n");
else
	{
	fprintf(Allfile,"item,cond");
	for(region = 0; region < nregmax; region ++)
		fprintf(Allfile,",L%d",region+1);
	fprintf(Allfile,"\n");
	}
for(index=0;index<ni;index++)
	{
	region = 0;
	if(fgets(buff,MAXLINE,conbuff) EQ NULL)
		{
		printf("\nError reading control file, item %d ",index+1);
		exit(1);
		}
//	if((tempitem = readnext(0)) EQ ERR)	/* get item number */
//		{
//		printf("\nError reading item # in control file, item %d ",index+1);
//		exit(1);
//		}
//	if((tempcond = readnext(1)) EQ ERR)		/* cond # */
//		{
//		printf("\nError reading cond # in control file, item %d ",index+1);
//		exit(1);
//		}

	tempitem = readnext(0);
	tempcond = readnext(1);

	if(tempitem >= nimin && tempitem < (nimin+nitot) && tempcond >= ncmin && tempcond < (ncmin+nctot))	/* skip out sens */
		{
		nregion = readnext(1);	/* number of regions */
		if(nregion > nregmax)
			{
			printf("\nPROBLEMS: %d is more regions that you calloc'd space for",nregion);
			exit(1);
			}
		readnext(1);		/* skip over constant 0 at start */
		start = 0;
		if(!wide)
			{
			for(region = 1; region < nregion; region++)
				{
				end =  readnext(1);
				fprintf(Allfile,"%d,%d,%d,%d\n",tempitem,tempcond,region,end-start);
				start = end;
				} 
			}
		else
			{
			fprintf(Allfile,"%d,%d,",tempitem,tempcond);
			for(region = 1; region < nregion; region++)
				{
				end =  readnext(1);
				fprintf(Allfile,"%d,",end-start);
				start = end;
				}
			fprintf(Allfile,"\n");
			}
		} 
	} 
} /*END GET CONTROL*/


