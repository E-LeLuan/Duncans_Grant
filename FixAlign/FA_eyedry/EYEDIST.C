char version[] = "2/27/93";
/*...................................................
copyright 1990 Charles Clifton. Users of this program are permitted
to modify and distribute it at no charge but may not sell it or
include any of its code in a commercial program.

EYEDIST.C = program for getting distributions of eye fixation
durations in a specified region (first fixations, first pass
fixations, all fixations), for each condition

modification of EYEDRY.C, a
program for analyzing first fixation data from eyetracker.
Assumes EYEWASH output as input.
Modification of old SEGMENT program.

Assumes data consisting of:
... cond# ... item# ... #fixations in sentence x1 y1 st1 et1 x2 y2 st2 et2 ...
optionally with question to be discarded after each trial

VERSION DESIGNED TO TAKE EXCEPTIONS FILE, IN FORMAT:
item# +-changetocond#
item# +-changetocond#
...
6/88: if changetocond == 99, item is thrown out

it does the following things:
	1. writes a file of mean values for each combination
	of subject,item, subcondition, and region (where 
	subcondition refers to the first, second,...nth
	condition used for an item)
	2. writes a file of mean values for each combination
	of subject, condition, and region, averaged over items
	3. writes a file of mean values for each combination
	of item, condition, and region, averaged over subjects
	4. writes to the screen and optionally the printer the
	means over items, and the means over subjects and
	items, of the data for each condition and region

To run it, you need a control file with one line for each
item/condition combination used in the experiment, 
containing the following information:

item#   cond#   #regions  start of 1st region (=0) start of 2nd region
  .... start of nth region 

When the control file gets read in, the condition number for 
a sentence gets stored as the start of the first region 
which must always be 0 anyway.

Note, the condition numbers indicated are those in the datafile
before adjustment from the exceptions file.

The control file can be generated by combining the program WORDPOS.C
and your experiment-running program, and compiling and running the
resulting program.

2/28/88: code added to allow rejection of trials where the question
was answered incorrectly
6/88: restructured to calloc data storage area
6/4/88: converted from segment to FF
......................................................*/


#include "stdio.h"
#include "stdlib.h"
#include "math.h"
#include "ctype.h"
#include "alloc.h"
#include "dos.h"
#define EQ ==
#define MAXLINE 600
#define MAXLINEX 3500
#define TRUE 1
#define FALSE 0
#define ERR NULL			/* from CPM86 */
void movenextnumber();
void movebacknumber();
char buff [MAXLINEX];
char qbuff[MAXLINEX];
FILE *dbuff,*subbuff,*senbuff,*allbuff;
FILE *printer;
char file [MAXLINE];
char *tbuff;
int NBINS;	/* how many categories in distribution */

int ti1,ti2,ti3;			/* temporary indices into arrays */
int *DAT;	/* conditions x observations array of individual durations */
int *DAT_INDEX;
int *BINS;	/* bins for counting observations */
int *C;	/* control info; indices are sentence#-1,
	item-cond #, and region#-1; values are	region-starts */
int *NR;	/* number of regions in each item/cond combo */
int debug;
FILE *datalst,*except;
int vexcept[200];		/* 200 items max */
int exceptflag;
int grain;
int width,yoffset,max_y;
int anal;
int chatter;
int which_reg;
/******* START OF MAIN PROGRAM HERE ***********/


main()
{
int nsub,ni,k,j,i,l,jc;
int nimax,senfileq,allfileq,subfileq;
int nitot,nctot;
int nimin;
int nsmax,nscmax,qskip;
int ncmin,ncmax;
int cpos,ipos,npos,dpos;
int shorttime,longtime,highbin;
int lookahead,minq, maxq,qcpos,qresppos;
char string[100];
char c;
struct date today;
yoffset = 0;			/* should be 0 eventually */
printer = fopen("prn","w");

fprintf(printer,"\nVersion %s\n",version);
printf("\nEYEDIST version %s\n",version);
getdate(&today);
fprintf(printer,"\nDATE: %d/%d/%d\n",today.da_mon,today.da_day,today.da_year);
printf("\nThis version is for normal and eyetracker data on same line");
printf("\nand optionally permits question data to be discarded after each trial.");
printf("\nThis version permits an EXCEPTIONS FILE of item-condition adjustment\npairs.");
printf("\n\nType an identifying string to print out\n");
gets(string);
fprintf(printer,"\n%s\n",string);
printf("\nDebug level (0 = no, 1 = getcontrol, 2 = sortsubj, 3 = elsewhere - ");
debug = atoi(gets(buff));
fprintf(printer,"debug level %d\n",debug);

printf("Does the question after a sentence have the same COND and ITEM\nnumbers as the sentences and fall on the next line? y or n ");
qskip = (tolower(*(gets(buff))) EQ 'y')? 2 : 1;
fprintf(printer,"questions on next line, same COND number? %c\n",buff[0]);

if(qskip != 2)
	{
	printf("Do you want to eliminate trials on the basis of errors to questions? y or n: ");
	lookahead = (tolower(*(gets(buff))) == 'y')? TRUE : FALSE;
	if(lookahead)
		{
		printf("What is the smallest legal COND number for a question? ");
		minq = atoi(gets(buff));
		printf("What is the largest legal COND number for a question? ");
		maxq = atoi(gets(buff));
		printf("What question response keeps a trial? ");
		lookahead = atoi(gets(buff));
		fprintf(printer,"Eliminating trials when question answer != %d.\n",lookahead);
		}
	}
printf("What is smallest numbered experimental item? - ");
nimin = atoi(gets(buff));
fprintf(printer,"# smallest item %d\n",nimin);

printf("What is largest numbered experimental item? - ");
nimax = atoi(gets(buff));
fprintf(printer,"# largest item %d\n",nimax);
nitot = nimax-nimin+1;

printf("How many regions maximum? - ");
nsmax = atoi(gets(buff));
fprintf(printer,"# regions %d\n",nsmax);

printf("Which is the critical region? - ");
which_reg = atoi(gets(buff))-1;
fprintf(printer,"critical region is %d\n",which_reg+1);

printf("What is the smallest condition number (after any exception adjustment)? - ");
ncmin = atoi(gets(buff));
fprintf(printer,"smallest condition number %d\n",ncmin);

printf("What is the largest condition number (after exception adjustment)? -" );
ncmax = atoi(gets(buff));
fprintf(printer,"largest condition number %d\n",ncmax);
nctot = ncmax-ncmin+1;

printf("How many subconditions maximum for any one item? - ");
nscmax = atoi(gets(buff));
fprintf(printer,"subconditions/item %d\n",nscmax);

printf("What field is the condition number in? ");
cpos = atoi(gets(buff));
printf("What field is the item number in? ");
ipos = atoi(gets(buff));
printf("What field is the number-of-fixations number in? ");
npos = atoi(gets(buff));
printf("What field do the data start in? ");
dpos = atoi(gets(buff));
fprintf(printer,"cond, item, no-of-fix, data fields: %d %d %d %d\n",cpos,ipos,npos,dpos);
printf("Longest fixation time, msec (truncate if above): ");
longtime = atoi(gets(buff));
fprintf(printer,"Upper limit = %d\n",longtime);
printf("Shortest fixation time, msec (discard if below): ");
shorttime = atoi(gets(buff));
fprintf(printer,"Lower limit = %d\n",shorttime);
if(lookahead)
	{
	printf("What field is the question condition number in? ");
	qcpos = atoi(gets(buff));
	printf("What field is the question response in? ");
	qresppos = atoi(gets(buff));
	}
printf("What is the screen width in characters? 60 or 72: ");
width = atoi(gets(buff));
printf("What is the maximum number of lines of text? ");
max_y = atoi(gets(buff));
fprintf(printer,"Width = %d, max lines = %d\n",width,max_y);
printf("What is the name of the file that lists data files? ");
while((datalst=fopen(gets(file),"r")) EQ NULL)
	printf("\nBad file name, try again.\n");
fprintf(printer,"datalst = %s\n",file);
nsub = 0;
while((c = fgetc(datalst)) != EOF)	/* count the subjects */
	{
	if(c == '\n')
		nsub++;
	}
rewind(datalst);
printf("\n%d subjects\n",nsub);
printf("Any exceptions file? y or n: ");
exceptflag = (tolower(*gets(buff)) EQ 'y') ? TRUE : FALSE;
if(exceptflag)
	{
	printf("What is the exceptions file name? ");
	while((except=fopen(gets(file),"r")) EQ NULL)
		printf("\nBAD FILE NAME, TRY AGAIN\n");
	fprintf(printer,"Exceptions file %s\n",file);
	while(fscanf(except,"%d %d",&i,&j) != ERR)
		{
		fprintf(printer,"item %d condition adjustment %d\n",i,j);
		vexcept[i-nimin] = j;	/* vector of condition adjustment values */
		}
	}
fprintf(printer,"\n\n");
printf("\nAssuming y offset is 0.\n");

if((C = (int *)(calloc(nitot*nctot*nsmax,sizeof(int))))==NULL)
	oops("C");
if((NR = (int *)(calloc(nitot*nctot,sizeof(int))))==NULL)
	oops("NR");
getcontrol(nimin,nitot,ncmin,nctot,nsmax);	/* get the control list into C */


while(1)
{
printf("\nWhich analysis?\n  1 = first fixation\n  2 = total times\n  3 = first pass times \n  4 = all individual fixations\n  5 = time to go past region\n0 TO QUIT: ");
anal = atoi(gets(string));
if(!anal)
	goto end;
printf("How many bins do you want in the distribution (e.g. 20): ");
NBINS = atoi(gets(string));
printf("What is the starting value (ms) of the highest bin (e.g. 950): ");
highbin = atoi(gets(string));
grain = highbin/(NBINS-1);
fprintf(printer,"analysis %d, %d bins, start of highest bin = %d, each %d ms wide\n",anal, NBINS, highbin, grain);
if((DAT = (int *)(calloc(nctot*5000,sizeof(int))))==NULL)
	oops("DAT");
if((DAT_INDEX = (int *)(calloc(nctot,sizeof(int))))==NULL)
	oops("DAT_INDEX");
if((BINS = (int *)(calloc(nctot*NBINS,sizeof(int))))==NULL)
	oops("BINS");
printf("\nType an identifying string to print out\n");
gets(string);
fprintf(printer,"\n%s\n",string);
printf("Output file name: ");
while((subbuff=fopen(gets(file),"w")) EQ NULL)
    printf("\nBAD FILE NAME, TRY AGAIN\n");
fprintf(printer,"Output file %s\n",file);
printf("Do you want information about long and short times printed? y or n -");
chatter = (tolower(*(gets(buff))) == 'y') ? TRUE : FALSE;

if(debug != 0)
	printf("\nnimax = %d nscmax = %d",nimax,nscmax);
for(i=0;i<nsub;i++)
	{
/*	printf("\nSubject %d; what is y offset? ",i+1);
	yoffset = atoi(gets(string));*/
	while(sortsubject(i,nimin,nimax,ncmin,ncmax,nscmax,qskip,cpos,ipos,npos,dpos,shorttime,longtime,lookahead,minq,maxq,qcpos,qresppos,nitot,nctot) EQ ERR)
	    fprintf(printer,"\nScrewup on subject %d",i+1);
	if(debug != 0)
		printf("\nEnd of subject %d",i+1);
	}
/* NEW KLUDGE */
summarize(ncmin,ncmax,longtime,shorttime);
fprintf(printer,"\f\n");
free(DAT);
free(DAT_INDEX);
free(BINS);
fclose(subbuff);
rewind(datalst);
if(exceptflag)
	rewind(except);
}			/* end of loop for type of analysis */
end:
free(C);
free(NR);
fclose(datalst);
fclose(printer);
if(exceptflag)
	fclose(except);
}  



/* FUNCTION to get control list into C[item][subcond][region]   */
/* item is real item number */
/* real condition number is stored at region = 0 */


getcontrol(nimin,nitot,ncmin,nctot,nsmax)
int nimin,nitot,ncmin,nctot,nsmax;
{
int region,index,icond;
int nregion;
int item,tempitem,tempcond;
FILE *conbuff;
int ni;
char c;
item = 0;
icond = -1;	/* will go to 0 first time around */

printf("\n Control file name? - ");
while((conbuff=fopen(gets(file),"r")) EQ 0)
	printf("\nCan't find control file; try again.\n");
fprintf(printer,"control file %s\n",file);
ni = 0;
while((c = fgetc(conbuff)) != EOF)	/* count the lines */
	{
	if(c == '\n')
		ni++;
	}
fprintf(printer,"control file length %d\n",ni);
rewind(conbuff);
for(index=0;index<ni;index++)
	{
	region = 0;
	if(fgets(buff,MAXLINE,conbuff) EQ NULL)
		{
		printf("\nError reading control file, item %d ",index+1);
		exit(1);
		}
	if((tempitem = readnext(0)) EQ ERR)	/* get item number */
		{
		printf("\nError reading item # in control file, item %d ",index+1);
		exit(1);
		}
	if((tempcond = readnext(1)) EQ ERR)		/* cond # */
		{
		printf("\nError reading cond # in control file, item %d ",index+1);
		exit(1);
		}
	if(tempitem >= nimin && tempitem < (nimin+nitot) && tempcond >= ncmin && tempcond < (ncmin+nctot))	/* skip out sens */
		{
		if(tempitem-nimin EQ item)	/* this item same as last one */
			icond++;
		else
			{
			icond = 0;
			item = tempitem -nimin;
			}
		*(C+icond*nitot + item) = tempcond;	
		if(debug == 1)
			printf("\nRead C: %d at icond %d item %d",*(C+icond*nitot + item),icond,item);
		nregion = (*(NR + icond*nitot + item) = readnext(1));	/* number of regions */
		if(nregion <= which_reg+1)
			{
			printf("\nPROBLEMS: %d regions is fewer than the specified critical region + 1",nregion);
			exit(1);
			}
		readnext(1);		/* skip over constant 0 at start */
		if(debug EQ 1)
			printf("\nGETCCONTROL: ITEM %d CONDITION %d",item+1,*(C+icond*nitot+item));	
		for(region = 1; region <= which_reg+1; region++)	/* get start of reg after crit reg */
			{
			*(C+ region*nitot*nctot + icond*nitot + item) = readnext(1);
			if(debug EQ 1)	/* read in region starts */
				printf("\n  C[%d][%d][%d] = %d",item,icond,region,*(C+region*nitot*nctot+icond*nitot+item));
			}
		}
	}
fclose(conbuff);
}


/* reads next ASCII-coded number from buff[] */
/* starts at beginning of buff[] if control = 0 */


readnext(control)
int control;
{
static int bptr;
int value;
if(control EQ 0)
	bptr = 0;
while (!isdigit(*(buff+bptr)))
	bptr++;
value = atoi(buff+bptr);
while(isdigit(*(buff+bptr++)))
	;
if(debug EQ 1)
	printf("\nIn readnext: value = %d, bptr = %d, control = %d",value,bptr,control);
return(value);
}


/* FUNCTION FOR READING INDIVIDUAL SUBJECT DATA, SORTING INTO
DAT */

sortsubject(i,nimin,nimax,ncmin,ncmax,nscmax,qskip,cpos,ipos,npos,dpos,shorttime,longtime,lookahead,minq,maxq,qcpos,qresppos,nitot,nctot)
int i,nimin,nimax,nscmax,qskip,ncmin,ncmax,cpos,ipos,npos,dpos,shorttime,longtime,lookahead,minq,maxq,qcpos,qresppos,nitot,nctot;
{
FILE *gdbuff;
int fpt,lpt;
int endsen,region,sptrptr, cptrptr, icond, ns;
int temppos,temptime,temps,tempe,tempx,tempy;
int qcond,qresp;
int start_record;
int nregion,fixation;
int start_region,end_region;
int nextpos,nexttime;
int sumtime;
char *ttbuff;					/* temporary storage for data start */
fscanf(datalst,"%s",file);
fprintf(printer,"\n%s",file);
if((gdbuff=(fopen(file,"r"))) EQ NULL)
	{
	fprintf(printer,"\nPROBLEMS: Can't open file %s",file);
	return(ERR);                             /*get sen-b,-sen date*/
	}
if(debug EQ 2)
	printf("\nIn sortsubject, i = %d nimax = %d nscmax = %d gdbuff = %d",i,nimax,nscmax,gdbuff);
while(fgets(buff,MAXLINEX,gdbuff) != NULL)	/* keep going until EOF */
	{
	cptrptr = atoi(buff+spacebuff(buff,cpos));
	sptrptr = atoi(buff+spacebuff(buff,ipos));
	ns = sptrptr-nimin;
	if(exceptflag)
		{
		if(vexcept[ns] == 99)
			cptrptr = ncmax+1;		/* discard item */
		else
			cptrptr += vexcept[ns];	/* adjust condition */
		}
	if(debug EQ 2)
		printf("\n sentence %d, cond %d ",sptrptr,cptrptr);
				/* skip junk sentence plus question if needed */
	if(cptrptr < ncmin || cptrptr > ncmax || sptrptr > nimax || sptrptr<nimin)
		{
		if(debug EQ 2)
			printf("\nskipping junk sen # %d, cond # %d",sptrptr,cptrptr);
		if(qskip == 2)		/* questions with same cond number */
			if(fgets(buff,MAXLINEX,gdbuff) == NULL)
				{
				printf("\nEnd of file after item number %d, looking for question",sptrptr);
				fclose(gdbuff);
				return(1);
				}
		}
	else		/* OK condition number, get data position and data */
		{
		sumtime = 0;
		endsen = atoi(buff+spacebuff(buff,npos));
		tbuff = buff+spacebuff(buff,dpos);
		ttbuff = tbuff;
		if(debug EQ 2)
			{
			printf("\nSPTRPTR = %d",sptrptr);
			printf("\nCPTRPTR = %d",cptrptr);
			printf("\nENDSEN  = %d",endsen);
			}
		for(icond=0;icond<nscmax;icond++)	/* find match to cond # */
			{
			ti1 = icond * nitot + ns;
			if(debug == 2)
				printf("\n  icond %d *(C+ti1) %d cptrptr %d",icond,*(C+ti1),cptrptr);
			if(*(C+ti1) EQ cptrptr)
				break;
			}
		if(debug == 2)
			printf("\nFound condition match: icond = %d cptrptr = %d ti1 = %d",icond,cptrptr,ti1);
		if(icond EQ nscmax)
			{
			printf("\nSCREWUP! sen %d cond %d",sptrptr,cptrptr);
			exit(1);
			}
		if(debug EQ 2)
			printf("\n    NS = %d, adjusted cond = %d",ns,cptrptr);
		if(lookahead)		/* reject trials where question wrong */
			{
			do
				{
				if (fgets(qbuff,MAXLINEX,gdbuff) == NULL)
					{
					printf("\nPROBLEM finding question, condition %d.",cptrptr);
					exit(1);
					}
				qcond = atoi(qbuff + spacebuff(qbuff,qcpos));
			if(debug == 2)
				printf("\nQCOND = %d",qcond);
				}
			while(qcond < ncmin || (qcond > ncmax && (qcond < minq || qcond > maxq)));

			if(qcond >= ncmin && qcond <= ncmax)
				{
				printf("\nTROUBLES: found real trial before finding question, condition %d",cptrptr);
				exit(1);
				}
			else
				qresp = atoi(qbuff + spacebuff(qbuff,qresppos));
			if(debug == 2)
				printf("\nqcond = %d qresp = %d",qcond, qresp);
			}
		if(lookahead ==  qresp || lookahead == FALSE)
			{
			ti1 = icond*nitot + ns;
			region = which_reg;			/* do only for critical region */
			if(region >= (nregion = *(NR+ti1)))	/* outside range */
				{
				printf("\nNOPE: Region outside range");
				exit(1);
				}
			if(debug == 2)
				printf("\n  Examining region %d",region);
			ti2 = region*nitot*nctot + icond*nitot + ns;
			if(region == 0)
				start_region = 0;
			else
				start_region = *(C+ti2);
			if(region == nregion-1)		/* last region */
				end_region = start_region + 20;	/* fake */
			else
				end_region = *(C+ti2+nitot*nctot);
			tbuff = ttbuff;				/* set or reset buffpointer */
			for(fixation=0,start_record=FALSE;fixation < endsen; fixation++)
				{
				if(debug == 2)
					printf("\n fix %d",fixation);
				tempx = atoi(tbuff);			/* x pos of fix */
				movenextnumber();
				tempy = atoi(tbuff);			/* y pos of fix */
				movenextnumber();
				temps = atoi(tbuff);			/* start fix time */
				movenextnumber();
				tempe = atoi(tbuff);			/* end fix time */
				if(fixation < endsen-1)
					movenextnumber();
				temppos = tempx + (tempy-yoffset) * width;	/* fixation position */
				temptime = tempe-temps;
				if(!start_record)	/* skip past any bad initial fixations */
					{				
					if(temppos >= -1 && temppos < end_region)
						{
						start_record = TRUE;
						}
					}
				if(start_record && tempy >= 0 && tempy < max_y)	/* discard fixations with negative */
					{					/* or oversized y values as well as bad initial fix */
					if(debug == 2)
						{
						printf("\nfixation %d start_region %d, end_region %d temppos %d\n   tempx %d tempy %d temps %d tempe %d",fixation,start_region,end_region,temppos, tempx,tempy,temps,tempe);
						}
					if(anal == 1)
						fixation = ff(fixation,temppos,temptime,endsen,start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,icond);
							/* call to first fixation etc. routine */
					else if(anal == 2)
						fixation = tt(fixation,temppos,temptime,endsen,start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,icond,&sumtime);
					else if(anal == 3)
						fixation = fp(fixation,temppos,temptime,endsen,start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,icond,&sumtime);
					else if(anal == 4)
						fixation = af(fixation,temppos,temptime,endsen,start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,icond);
					else if(anal == 5)
						fixation = go_past(fixation,temppos,temptime,endsen,start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,icond,&sumtime);
					else
						{
						printf("\nCELT WELT BAMMY");
						exit(1);
						}
					}
				else if(debug == 2)
					printf("\nReject fixation %d: start_record = %d, tempy = %d",fixation,start_record,tempy);
				}
			if((anal==2 || anal==3 || anal == 5) && sumtime != 0)
				{
				*(DAT+icond*5000+*(DAT_INDEX+icond))=sumtime;
				(*(DAT_INDEX+icond))++;	/* increase count for this cond */
				}
			if(qskip == 2)		/* question on next line, same cond # */
				if(fgets(buff,MAXLINEX,gdbuff) == NULL)
					{
					printf("\nEnd of file after item number %d, looking for question",sptrptr);
					fclose(gdbuff);
					return(1);
					}
			}
		}
	}
fclose(gdbuff);
return(1);
}

/* PRINT OUT SUMMARY VALUES */
/* and write item by item file averaged over subjects */

summarize(ncmin,ncmax,longtime,shorttime)
int ncmin,ncmax,longtime,shorttime;
{
char temp[20];
int ns,icond,cond,region;
int ibin,iobs;
float tempbin,tempcount,total;

fprintf(printer,"\n\nFREQUENCY DISTRIBUTION (PERCENTAGES), BY CONDITIONS (bins are %d msec wide)\n\n",grain);
for(ibin=0;ibin<NBINS-1;ibin++)
	{
	fprintf(printer,"%4d",ibin*grain);
	if(!((ibin+1)%20))
		fprintf(printer,"\n");
	}
fprintf(printer,"MORE");
for(ibin=0;ibin<NBINS;ibin++)
	fprintf(subbuff,"%6d",ibin*grain);
fprintf(subbuff,"\n");
for(icond=0,cond=ncmin-1;cond<ncmax;icond++,cond++)
	{
	total = 0;
	for(ibin=0;ibin<NBINS;ibin++)
		*(BINS+ibin) = 0;
	for(iobs=0;iobs<(*(DAT_INDEX+icond));iobs++)
		{
		total += (float)(*(DAT+icond*5000+iobs));
		if(((*(DAT+icond*5000+iobs))/grain) < NBINS)
			(*(BINS+((*(DAT+icond*5000+iobs))/grain)))++;
		else
			(*(BINS+NBINS-1))++;	/* KLUDGE, OVER MAX */
		if(debug==3)
			printf("\nicond = %d iobs = %d time %d index %d",icond,iobs,(*(DAT+icond*5000+iobs)),(*(DAT+icond*5000+iobs))/grain);
		}
	if(*(DAT_INDEX + icond) != 0)
		fprintf(printer,"\n\nCONDITION %2d MEAN %6.0f  #OBSERVATIONS %5d\n",cond+1,total/((float)(*(DAT_INDEX+icond))),*(DAT_INDEX+icond));
	else
		fprintf(printer,"\n\nCONDITION %2d MEAN      0\n",cond+1);
	tempcount = (float)(*(DAT_INDEX+icond));
	for(ibin=0;ibin<NBINS;ibin++)
		{
/*		fprintf(printer,"%4d",*(BINS+ibin));
		fprintf(subbuff,"%5d",*(BINS+ibin));*/
		if(tempcount != 0)
			{
			tempbin = 100 * (float)(*(BINS+ibin));
			fprintf(printer,"%4d",(int)(tempbin/tempcount));
			fprintf(subbuff,"%6.1f",(tempbin/tempcount));
			}
		else
			{
			fprintf(printer,"   0");
			fprintf(subbuff,"     0");
			}
		}
	fprintf(subbuff,"\n");
	}
}



/***************************************************************************/
/* get specified datum from buff */
spacebuff(bptr,val)
char *bptr;
int val;
{
int i,j;
val--;
j=0;

if(val EQ 0)
	{
	while(isspace(*(bptr+j)))
		j++;
	return(j);
	}

for(i=0;i<val;i++)
	{
	while(isspace(*(bptr+j)))
		j++;	/* move to first/next nonspace */
	while(!isspace(*(bptr+j)))
		j++;	/* then move to next space */
	while(isspace(*(bptr+j)))
		j++;	/* and finally on to next nonspace */
	}
	j--;
return(j);
}

oops(string)
char string[];
{
printf("\nOut of allocation space at %s.",string);
exit(1);
}


void movenextnumber()
{
while(isspace(*tbuff))	/* move on to next number */
	tbuff++;
while(!isspace(*tbuff))
	tbuff++;
while(isspace(*tbuff))
	tbuff++;
}

void movebacknumber()
{
while(!isspace(*tbuff))
	tbuff--;
while(isspace(*tbuff))
	tbuff--;
while(!isspace(*tbuff))
	tbuff--;
}
/* routines for first fixation, total time, and first pass */


ff(fixation,temppos,temptime,endsen,start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,icond)
int fixation,temppos,temptime,endsen,start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,icond;
{
if(temppos > end_region && temptime > shorttime )
	fixation = endsen;		/* past the region; cut it short */
if(temppos >= start_region && temppos < end_region)
	{
	if(temptime >= longtime)			/* time longer than set for */
		{
		if(chatter)
			fprintf(printer,"\nLong time, cond %d item %d RT %d",cptrptr,sptrptr,temptime);
		temptime = longtime-1;
		}
	if(temptime > shorttime)
		{
		*(DAT+icond*5000+(*(DAT_INDEX+icond)))=temptime;
		(*(DAT_INDEX+icond))++;	/* increase count for this cond */
		fixation = endsen;	/* cut the loop short */
		if(debug == 3)
			printf("\nTime %d icond %d count %d",temptime,icond,*(DAT_INDEX+icond));
		}
	else if(chatter)
		fprintf(printer,"\nShort time, cond %d item %d RT %d",cptrptr,sptrptr,temptime);
	if(debug EQ 2)
		{
		printf("\nGOT FIX: REGION = %d fix = %d NS = %d DAT = %d",region,fixation,ns,*(DAT+icond*5000+(*(DAT_INDEX+icond))));
		}
	}
return(fixation);
}


tt(fixation,temppos,temptime,endsen,start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,icond,sumtime)
int fixation,temppos,temptime,endsen,start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,icond;
int *sumtime;
{
if(temppos >= start_region && temppos < end_region)
	{
	if(temptime >= longtime)			/* time longer than set for */
		{
		if(chatter)
			fprintf(printer,"\nLong time, cond %d item %d RT %d",cptrptr,sptrptr,temptime);
		temptime = longtime-1;
		}
	if(temptime > 0)
		{
		(*sumtime)+=temptime;
		if(debug == 3)
			printf("\nTime %d icond %d",temptime,icond);
		}
	else if(chatter)
		fprintf(printer,"\nShort time, cond %d item %d RT %d",cptrptr,sptrptr,temptime);
	if(debug EQ 2)
		{
		printf("\nGOT FIX: REGION = %d fix = %d NS = %d DAT = %d",region,fixation,ns,*(DAT+icond*5000+(*(DAT_INDEX+icond))));
		}

	}
return(fixation);
}


fp(fixation,temppos,temptime,endsen,start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,icond,sumtime)
int fixation, temppos,temptime,endsen,start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,icond;
int *sumtime;
{
if(temppos > end_region && temptime > shorttime)
	fixation = endsen;		/* past the region; cut it short */
else if(temppos < start_region && *sumtime != 0)	/* regress to before region */
	fixation = endsen;
else if(temppos >= start_region && temppos < end_region)
	{
	if(temptime >= longtime)			/* time longer than set for */
		{
		if(chatter)
			fprintf(printer,"\nLong time, cond %d item %d RT %d",cptrptr,sptrptr,temptime);
		temptime = longtime-1;	
		}
	if(temptime > 0)
		{
		(*sumtime) += temptime;
		if(debug == 3)
			printf("\nTime %d icond %d",temptime,icond);
		}
	else if(chatter)
		fprintf(printer,"\nShort time, cond %d item %d RT %d",cptrptr,sptrptr,temptime);
	if(debug EQ 2)
		{
		printf("\nGOT FIX: REGION = %d fix = %d NS = %d DAT = %d",region,fixation,ns,*(DAT+icond*5000+(*(DAT_INDEX+icond))));
		}
	}
return(fixation);
}

go_past(fixation,temppos,temptime,endsen,start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,icond,sumtime)
int fixation, temppos,temptime,endsen,start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,icond;
int *sumtime;
{
if(temppos > end_region && temptime > shorttime)
	fixation = endsen;		/* past the region; cut it short */
else if(temppos >= start_region && temppos < end_region)
	{
	if(temptime >= longtime)			/* time longer than set for */
		{
		if(chatter)
			fprintf(printer,"\nLong time, cond %d item %d RT %d",cptrptr,sptrptr,temptime);
		temptime = longtime-1;	
		}
	if(temptime > 0)
		{
		(*sumtime) += temptime;
		if(debug == 3)
			printf("\nTime %d icond %d",temptime,icond);
		}
	else if(chatter)
		fprintf(printer,"\nShort time, cond %d item %d RT %d",cptrptr,sptrptr,temptime);
	if(debug EQ 2)
		{
			printf("\nGOT FIX: REGION = %d fix = %d NS = %d DAT = %d",region,fixation,ns,*(DAT+icond*5000+(*(DAT_INDEX+icond))));
		}
	}
return(fixation);
}


af(fixation,temppos,temptime,endsen,start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,icond)
int fixation,temppos,temptime,endsen,start_region,end_region,shorttime,longtime,cptrptr,sptrptr,region,ns,icond;
{
if(temppos >= start_region && temppos < end_region)
	{
	if(temptime >= longtime)			/* time longer than set for */
		{
		if(chatter)
			fprintf(printer,"\nLong time, cond %d item %d RT %d",cptrptr,sptrptr,temptime);
		temptime = longtime-1;
		}
	if(temptime > 0)
		{
		*(DAT+icond*5000+*(DAT_INDEX+icond))=temptime;
		(*(DAT_INDEX+icond))++;	/* increase count for this cond */
		if(debug == 3)
			printf("\nTime %d icond %d count %d",temptime,icond,*(DAT_INDEX+icond));
		}
	else if(chatter)
		fprintf(printer,"\nShort time, cond %d item %d RT %d",cptrptr,sptrptr,temptime);
	if(debug EQ 2)
		{
		printf("\nGOT FIX: REGION = %d fix = %d NS = %d DAT = %d",region,fixation,ns,*(DAT+icond*5000+(*(DAT_INDEX+icond))));
		}
	}
return(fixation);
}
